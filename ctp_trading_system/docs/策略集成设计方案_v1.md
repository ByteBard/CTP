# CTP程序化交易系统 - 策略集成设计方案

**版本**: v1.0
**日期**: 2026-01-26
**状态**: 待审核

---

## 一、项目目标

将两个经过回测验证的高收益策略集成到CTP程序化交易系统：

| 策略 | 累计收益 | 交易笔数 | 特点 |
|------|---------|---------|------|
| H1e Tick | +13,706% | 67,926笔/16月 | IMB信号、秒级持仓、日复利 |
| LSTM L2 | +2,618% | 1,340笔/16月 | 深度学习、分钟级持仓、月复利 |

**核心要求**:
1. 策略代码基于原始回测验证的实现
2. 保持与原回测相同的收益表现
3. 支持手动切换和同时运行
4. 可配置仓位分配

---

## 二、系统架构

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         CTP 程序化交易系统                               │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐                 │
│  │  Web UI     │    │  策略管理器  │    │  风控引擎   │                 │
│  │  (FastAPI)  │◄──►│  (Manager)  │◄──►│  (Risk)    │                 │
│  └─────────────┘    └──────┬──────┘    └─────────────┘                 │
│                            │                                            │
│         ┌──────────────────┼──────────────────┐                        │
│         ▼                  ▼                  ▼                        │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐                 │
│  │ H1e Tick    │    │ LSTM L2     │    │ Demo Auto   │                 │
│  │ Strategy    │    │ Strategy    │    │ Strategy    │                 │
│  └──────┬──────┘    └──────┬──────┘    └──────┬──────┘                 │
│         │                  │                  │                        │
│         └──────────────────┼──────────────────┘                        │
│                            ▼                                            │
│                   ┌─────────────┐                                       │
│                   │ CTP Gateway │                                       │
│                   │ (交易网关)  │                                       │
│                   └──────┬──────┘                                       │
│                          │                                              │
│         ┌────────────────┼────────────────┐                            │
│         ▼                ▼                ▼                            │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐                     │
│  │ 行情订阅    │  │ 交易执行    │  │ 持仓查询    │                     │
│  │ (MD API)   │  │ (TD API)   │  │ (Query)    │                     │
│  └─────────────┘  └─────────────┘  └─────────────┘                     │
│                                                                         │
├─────────────────────────────────────────────────────────────────────────┤
│                         数据存储层                                       │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐                     │
│  │ trades.db   │  │ logs/       │  │ models/     │                     │
│  │ (SQLite)    │  │ (日志文件)  │  │ (LSTM模型)  │                     │
│  └─────────────┘  └─────────────┘  └─────────────┘                     │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 三、目录结构

```
ctp_trading_system/
├── strategy/
│   ├── __init__.py
│   ├── base_strategy.py          # 策略基类 (已有)
│   ├── demo_strategy.py          # 演示策略 (已有)
│   ├── strategy_manager.py       # [新增] 策略管理器
│   │
│   ├── h1e_tick/                 # [新增] H1e Tick策略
│   │   ├── __init__.py
│   │   ├── h1e_strategy.py       # 核心策略实现
│   │   ├── imb_calculator.py     # IMB信号计算
│   │   └── config.py             # 策略配置
│   │
│   └── lstm_l2/                  # [新增] LSTM L2策略
│       ├── __init__.py
│       ├── lstm_strategy.py      # 核心策略实现
│       ├── feature_engine.py     # 特征工程
│       ├── model_loader.py       # 模型加载器
│       └── config.py             # 策略配置
│
├── storage/                      # [新增] 数据存储
│   ├── __init__.py
│   ├── database.py               # SQLite数据库管理
│   ├── models.py                 # TradeRecord数据模型
│   └── trade_repository.py       # CRUD操作
│
├── risk/                         # [新增] 风控模块
│   ├── __init__.py
│   ├── risk_engine.py            # 风控引擎
│   └── daily_control.py          # 日内风控
│
└── web/
    └── api/
        └── strategy.py           # 策略API (已有，需扩展)
```

---

## 四、H1e Tick策略实现

### 4.1 核心逻辑 (来源: tick_strategy_v4_profit_run.py)

```python
# ctp_trading_system/strategy/h1e_tick/h1e_strategy.py

from dataclasses import dataclass
from typing import Optional, Tuple, Callable
from enum import Enum

class ExitReason(Enum):
    IMB_REVERSAL = "imb_reversal"    # 动力反转
    TRAIL_STOP = "trail_stop"        # 追踪止盈
    STOP_LOSS = "stop_loss"          # 止损
    TIMEOUT = "timeout"              # 超时
    MANUAL = "manual"                # 手动平仓

@dataclass
class H1eConfig:
    """H1e策略配置 - 来源: production_config.py"""
    # 入场条件
    imb_threshold: float = 0.8        # IMB触发阈值
    min_depth: int = 1500             # 最小盘口深度
    max_volatility: float = 0.00015   # 最大波动率
    signal_cooldown: int = 10         # 信号冷却(tick数)

    # 退出条件
    imb_exit_threshold: float = 0.2   # IMB反转退出阈值
    trail_trigger_ticks: float = 2.0  # 追踪止盈触发(tick)
    trail_stop_ticks: float = 1.0     # 追踪止盈止损(tick)
    stop_loss_ticks: float = 2.0      # 硬止损(tick)
    max_hold_ticks: int = 30          # 最大持仓(tick数)

    # 日内风控
    daily_stop_loss_pct: float = -0.007  # 日亏-0.7%停止
    max_daily_trades: int = 500

    # 合约参数
    tick_size: float = 1.0            # 最小变动价位
    commission_rate: float = 0.00005  # 手续费率


class H1eTickStrategy:
    """
    H1e Tick策略 - 基于IMB订单流不平衡信号

    原始收益: +13,706% (16个月, 67,926笔交易)
    核心逻辑来源: tick_strategy_v4_profit_run.py
    """

    def __init__(self, trading_system, config: H1eConfig):
        self.system = trading_system
        self.config = config
        self._running = False
        self._position = None          # 当前持仓
        self._last_signal_idx = -100   # 上次信号索引
        self._daily_pnl = 0.0          # 日内盈亏
        self._daily_trades = 0         # 日内交易数
        self._tick_buffer = []         # Tick缓冲区
        self._log_callback = None

    def calculate_imb(self, bid_vol: float, ask_vol: float) -> float:
        """
        计算IMB不平衡度
        来源: order_flow_imbalance.py

        公式: imb = (BidVol - AskVol) / (BidVol + AskVol + 1)
        范围: -1 到 +1
        含义: >0.8 买方强势, <-0.8 卖方强势
        """
        return (bid_vol - ask_vol) / (bid_vol + ask_vol + 1)

    def check_entry_signal(self, tick_data: dict) -> Optional[int]:
        """
        检查入场信号

        条件:
        1. |IMB| >= 0.8
        2. 盘口深度 >= 1500
        3. 波动率 <= 0.00015
        4. 冷却期已过

        返回: 1=做多, -1=做空, None=无信号
        """
        imb = tick_data.get('imb', 0)
        depth = tick_data.get('total_depth', 0)
        volatility = tick_data.get('volatility', 0)
        tick_idx = tick_data.get('tick_idx', 0)

        # 冷却期检查
        if tick_idx - self._last_signal_idx < self.config.signal_cooldown:
            return None

        # 条件检查
        if abs(imb) < self.config.imb_threshold:
            return None
        if depth < self.config.min_depth:
            return None
        if volatility > self.config.max_volatility:
            return None

        # 日内风控检查
        if self._daily_pnl <= self.config.daily_stop_loss_pct:
            self._log("RISK", "WARNING", f"日内亏损达到{self._daily_pnl*100:.2f}%, 停止交易")
            return None
        if self._daily_trades >= self.config.max_daily_trades:
            return None

        return 1 if imb > 0 else -1

    def check_exit_signal(self, tick_data: dict) -> Optional[ExitReason]:
        """
        检查出场信号 (V4利润奔跑版)
        来源: tick_strategy_v4_profit_run.py find_next_move_v4()

        规则优先级:
        1. 动力反转 (IMB衰退)
        2. 追踪止盈 (获利回吐)
        3. 止损 (硬止损)
        4. 超时 (强制平仓)
        """
        if not self._position:
            return None

        current_price = tick_data.get('mid_price', 0)
        current_imb = tick_data.get('imb', 0)
        hold_ticks = tick_data.get('tick_idx', 0) - self._position['entry_idx']

        entry_price = self._position['entry_price']
        direction = self._position['direction']

        # 计算盈亏(tick数)
        price_diff = current_price - entry_price
        current_pnl_ticks = price_diff / self.config.tick_size * direction

        # 更新最大盈利
        self._position['max_pnl_ticks'] = max(
            self._position.get('max_pnl_ticks', 0),
            current_pnl_ticks
        )
        max_pnl_ticks = self._position['max_pnl_ticks']

        # 规则1: 动力反转退出
        if direction == 1 and current_imb < self.config.imb_exit_threshold:
            return ExitReason.IMB_REVERSAL
        if direction == -1 and current_imb > -self.config.imb_exit_threshold:
            return ExitReason.IMB_REVERSAL

        # 规则2: 追踪止盈
        if max_pnl_ticks >= self.config.trail_trigger_ticks:
            if current_pnl_ticks <= self.config.trail_stop_ticks:
                return ExitReason.TRAIL_STOP

        # 规则3: 止损
        if current_pnl_ticks <= -self.config.stop_loss_ticks:
            return ExitReason.STOP_LOSS

        # 规则4: 超时
        if hold_ticks >= self.config.max_hold_ticks:
            return ExitReason.TIMEOUT

        return None

    def on_tick(self, tick_data: dict):
        """
        Tick数据回调 - 策略主循环

        tick_data结构:
        {
            'datetime': datetime,
            'last_price': float,
            'bid_price1': float,
            'bid_volume1': int,
            'ask_price1': float,
            'ask_volume1': int,
            'volume': int,
            'tick_idx': int
        }
        """
        if not self._running:
            return

        # 计算IMB和其他特征
        tick_data['imb'] = self.calculate_imb(
            tick_data['bid_volume1'],
            tick_data['ask_volume1']
        )
        tick_data['mid_price'] = (tick_data['bid_price1'] + tick_data['ask_price1']) / 2
        tick_data['total_depth'] = tick_data['bid_volume1'] + tick_data['ask_volume1']

        # 计算波动率 (需要历史数据)
        self._tick_buffer.append(tick_data['mid_price'])
        if len(self._tick_buffer) > 20:
            self._tick_buffer.pop(0)
            returns = [(self._tick_buffer[i] - self._tick_buffer[i-1]) / self._tick_buffer[i-1]
                      for i in range(1, len(self._tick_buffer))]
            tick_data['volatility'] = np.std(returns) if returns else 0
        else:
            tick_data['volatility'] = 0

        # 有持仓时检查出场
        if self._position:
            exit_reason = self.check_exit_signal(tick_data)
            if exit_reason:
                self._close_position(tick_data, exit_reason)
                return

        # 无持仓时检查入场
        else:
            direction = self.check_entry_signal(tick_data)
            if direction:
                self._open_position(tick_data, direction)

    def _open_position(self, tick_data: dict, direction: int):
        """开仓"""
        entry_price = tick_data['mid_price']

        self._position = {
            'direction': direction,
            'entry_price': entry_price,
            'entry_idx': tick_data['tick_idx'],
            'entry_time': tick_data['datetime'],
            'entry_imb': tick_data['imb'],
            'max_pnl_ticks': 0
        }

        self._last_signal_idx = tick_data['tick_idx']
        self._daily_trades += 1

        # 发送CTP开仓指令
        offset = 'OPEN'
        direction_str = 'BUY' if direction == 1 else 'SELL'

        self._log("H1e", "INFO",
            f"开仓信号: {direction_str} @ {entry_price:.2f}, IMB={tick_data['imb']:.3f}")

        # 调用交易系统下单
        self.system.send_order(
            instrument_id=self.config.instrument_id,
            direction=direction_str,
            offset=offset,
            price=entry_price,
            volume=1
        )

    def _close_position(self, tick_data: dict, reason: ExitReason):
        """平仓"""
        exit_price = tick_data['mid_price']
        entry_price = self._position['entry_price']
        direction = self._position['direction']

        # 计算盈亏
        pnl_ticks = (exit_price - entry_price) / self.config.tick_size * direction
        pnl_pct = (exit_price - entry_price) / entry_price * direction
        net_pnl_pct = pnl_pct - self.config.commission_rate * 2

        # 更新日内盈亏
        self._daily_pnl += net_pnl_pct

        self._log("H1e", "INFO",
            f"平仓: {reason.value}, PnL={pnl_ticks:.1f}跳, 净收益={net_pnl_pct*100:.4f}%")

        # 发送CTP平仓指令
        direction_str = 'SELL' if direction == 1 else 'BUY'

        self.system.send_order(
            instrument_id=self.config.instrument_id,
            direction=direction_str,
            offset='CLOSE',
            price=exit_price,
            volume=1
        )

        # 清空持仓
        self._position = None

    def _log(self, source: str, level: str, message: str):
        """日志回调"""
        if self._log_callback:
            self._log_callback(source, level, message)

    def start(self):
        """启动策略"""
        self._running = True
        self._daily_pnl = 0.0
        self._daily_trades = 0
        self._tick_buffer = []
        return True

    def stop(self):
        """停止策略"""
        self._running = False
        if self._position:
            self._log("H1e", "WARNING", "策略停止，强制平仓")
            # 市价平仓逻辑...

    def get_status(self) -> dict:
        """获取状态"""
        return {
            'name': 'H1e_TICK',
            'running': self._running,
            'position': self._position,
            'daily_pnl': self._daily_pnl,
            'daily_trades': self._daily_trades
        }
```

### 4.2 IMB信号计算器

```python
# ctp_trading_system/strategy/h1e_tick/imb_calculator.py

import numpy as np
from collections import deque
from typing import Tuple

class IMBCalculator:
    """
    订单流不平衡度计算器
    来源: order_flow_imbalance.py
    """

    def __init__(self, lookback: int = 20):
        self.lookback = lookback
        self._price_buffer = deque(maxlen=lookback)
        self._imb_buffer = deque(maxlen=lookback)

    def calculate_imb_1(self, bid_vol: float, ask_vol: float) -> float:
        """
        基础IMB: 买卖盘口不平衡

        公式: (BidVol - AskVol) / (BidVol + AskVol + 1)
        范围: [-1, +1]
        """
        denominator = bid_vol + ask_vol + 1
        return (bid_vol - ask_vol) / denominator

    def calculate_volatility(self, mid_price: float) -> float:
        """
        计算20tick滚动波动率
        """
        self._price_buffer.append(mid_price)

        if len(self._price_buffer) < 2:
            return 0.0

        prices = list(self._price_buffer)
        returns = np.diff(prices) / prices[:-1]
        return np.std(returns)

    def calculate_features(self, tick_data: dict) -> dict:
        """
        计算完整特征集

        输入tick_data:
        - bid_price1, bid_volume1
        - ask_price1, ask_volume1
        - last_price, volume

        输出features:
        - imb_1: 基础IMB
        - mid_price: 中间价
        - total_depth: 总深度
        - volatility: 波动率
        - spread: 价差
        """
        bid_vol = tick_data.get('bid_volume1', 0)
        ask_vol = tick_data.get('ask_volume1', 0)
        bid_price = tick_data.get('bid_price1', 0)
        ask_price = tick_data.get('ask_price1', 0)

        mid_price = (bid_price + ask_price) / 2

        features = {
            'imb_1': self.calculate_imb_1(bid_vol, ask_vol),
            'mid_price': mid_price,
            'total_depth': bid_vol + ask_vol,
            'spread': ask_price - bid_price,
            'volatility': self.calculate_volatility(mid_price)
        }

        self._imb_buffer.append(features['imb_1'])

        return features
```

---

## 五、LSTM L2策略实现

### 5.1 核心逻辑 (来源: 纯累积LSTM_带缓存.py)

```python
# ctp_trading_system/strategy/lstm_l2/lstm_strategy.py

import torch
import torch.nn as nn
import numpy as np
import pickle
from dataclasses import dataclass
from typing import Optional, List
from enum import Enum
from pathlib import Path

class PositionState(Enum):
    FLAT = "flat"      # 平仓
    PROBE = "probe"    # 探针仓 (0.3手)
    FULL = "full"      # 满仓 (1手)
    TRAIL = "trail"    # 追踪仓

@dataclass
class LSTMConfig:
    """LSTM策略配置 - 来源: 纯累积LSTM_带缓存.py"""
    # 模型参数
    model_path: str = ""              # LSTM模型路径
    scaler_path: str = ""             # Scaler路径
    seq_len: int = 10                 # 序列长度
    hidden_dim: int = 64              # 隐层维度

    # 信号阈值
    signal_threshold: float = 0.5     # 预测概率阈值
    rsi_upper: float = 60             # RSI上限过滤
    rsi_lower: float = 40             # RSI下限过滤

    # 仓位管理
    probe_size: float = 0.3           # 探针仓位
    full_size: float = 1.0            # 满仓仓位

    # 退出条件
    probe_to_full: float = 0.003      # 探针升满仓阈值 (0.3%)
    probe_sl: float = 0.003           # 探针止损 (0.3%)
    full_to_trail: float = 0.005      # 满仓转追踪 (0.5%)
    full_sl: float = 0.004            # 满仓止损 (0.4%)
    trail_dd: float = 0.30            # 追踪回撤止损 (30%)
    trail_max: float = 0.015          # 追踪最大止盈 (1.5%)

    # 成本
    commission_rate: float = 0.00005  # 手续费率
    slippage: float = 0.00025         # 滑点


class LSTMModel(nn.Module):
    """
    LSTM预测模型
    来源: 纯累积LSTM_带缓存.py

    架构: 双层LSTM (64维隐层) + FC (64->32->1) + Sigmoid
    """

    def __init__(self, input_dim: int, hidden_dim: int = 64, num_layers: int = 2):
        super().__init__()
        self.lstm = nn.LSTM(
            input_dim,
            hidden_dim,
            num_layers,
            batch_first=True,
            dropout=0.2
        )
        self.fc = nn.Sequential(
            nn.Linear(hidden_dim, 32),
            nn.ReLU(),
            nn.Linear(32, 1),
            nn.Sigmoid()
        )

    def forward(self, x):
        lstm_out, _ = self.lstm(x)
        return self.fc(lstm_out[:, -1, :]).squeeze(-1)


class LSTML2Strategy:
    """
    LSTM L2策略 - 基于深度学习的中频交易

    原始收益: +2,618% (16个月, 1,340笔交易)
    核心逻辑来源: 纯累积LSTM_带缓存.py
    """

    def __init__(self, trading_system, config: LSTMConfig):
        self.system = trading_system
        self.config = config
        self._running = False
        self._model = None
        self._scaler = None
        self._state = PositionState.FLAT
        self._position = None
        self._feature_buffer = []
        self._log_callback = None
        self._device = 'cuda' if torch.cuda.is_available() else 'cpu'

    def load_model(self) -> bool:
        """
        加载LSTM模型和Scaler

        模型位置: C:\Repo\future-trading-strategy\experiments\model_cache_tick\
        """
        try:
            model_path = Path(self.config.model_path)
            scaler_path = Path(self.config.scaler_path)

            if not model_path.exists() or not scaler_path.exists():
                self._log("LSTM", "ERROR", f"模型文件不存在: {model_path}")
                return False

            # 加载Scaler
            with open(scaler_path, 'rb') as f:
                self._scaler = pickle.load(f)

            # 确定输入维度
            input_dim = self._scaler.n_features_in_

            # 加载模型
            self._model = LSTMModel(input_dim, self.config.hidden_dim)
            self._model.load_state_dict(torch.load(model_path, map_location=self._device))
            self._model.to(self._device)
            self._model.eval()

            self._log("LSTM", "INFO", f"模型加载成功, 输入维度={input_dim}")
            return True

        except Exception as e:
            self._log("LSTM", "ERROR", f"模型加载失败: {e}")
            return False

    def predict(self, features: np.ndarray) -> float:
        """
        LSTM预测

        输入: 特征序列 (seq_len, n_features)
        输出: 上涨概率 (0-1)
        """
        if self._model is None:
            return 0.5

        # 标准化
        features_scaled = self._scaler.transform(features)

        # 创建序列
        if len(features_scaled) < self.config.seq_len:
            return 0.5

        seq = features_scaled[-self.config.seq_len:]
        x = torch.FloatTensor(seq).unsqueeze(0).to(self._device)

        # 预测
        with torch.no_grad():
            prob = self._model(x).item()

        return prob

    def generate_signal(self, prob: float, rsi: float) -> int:
        """
        生成交易信号
        来源: 纯累积LSTM_带缓存.py generate_signals()

        规则:
        - prob > 0.5 且 RSI < 60 → 做多
        - prob < 0.5 且 RSI > 40 → 做空
        - 否则 → 无信号
        """
        if prob > self.config.signal_threshold and rsi < self.config.rsi_upper:
            return 1  # 做多
        elif prob < self.config.signal_threshold and rsi > self.config.rsi_lower:
            return -1  # 做空
        return 0  # 无信号

    def on_bar(self, bar_data: dict):
        """
        分钟Bar数据回调 - 策略主循环
        来源: 纯累积LSTM_带缓存.py run_state_machine_backtest()

        bar_data结构:
        {
            'datetime': datetime,
            'open': float,
            'high': float,
            'low': float,
            'close': float,
            'volume': int,
            'features': dict  # 93个特征
        }
        """
        if not self._running:
            return

        # 添加到特征缓冲
        features = bar_data.get('features', {})
        feature_array = np.array(list(features.values()))
        self._feature_buffer.append(feature_array)

        # 保持缓冲区大小
        if len(self._feature_buffer) > self.config.seq_len * 2:
            self._feature_buffer = self._feature_buffer[-self.config.seq_len * 2:]

        # 预测
        if len(self._feature_buffer) >= self.config.seq_len:
            feature_matrix = np.array(self._feature_buffer)
            prob = self.predict(feature_matrix)
        else:
            prob = 0.5

        rsi = features.get('rsi_14', 50)
        price = bar_data['close']

        # 状态机逻辑
        self._run_state_machine(price, prob, rsi, bar_data['datetime'])

    def _run_state_machine(self, price: float, prob: float, rsi: float, dt):
        """
        三态仓位状态机
        来源: 纯累积LSTM_带缓存.py

        状态转换:
        Flat -> Probe: 信号触发
        Probe -> Full: 盈利0.3%
        Probe -> Flat: 亏损0.3%
        Full -> Trail: 盈利0.5%
        Full -> Flat: 亏损0.4%
        Trail -> Flat: 回撤30% 或 盈利1.5%
        """

        if self._state == PositionState.FLAT:
            signal = self.generate_signal(prob, rsi)
            if signal != 0:
                self._open_probe(price, signal, dt)

        elif self._state == PositionState.PROBE:
            pnl_pct = self._calculate_pnl_pct(price)

            if pnl_pct >= self.config.probe_to_full:
                self._upgrade_to_full(price, dt)
            elif pnl_pct <= -self.config.probe_sl:
                self._close_position(price, "probe_sl", dt)

        elif self._state == PositionState.FULL:
            pnl_pct = self._calculate_pnl_pct(price)
            self._position['peak_pnl'] = max(
                self._position.get('peak_pnl', 0),
                pnl_pct
            )

            if pnl_pct >= self.config.full_to_trail:
                self._upgrade_to_trail(dt)
            elif pnl_pct <= -self.config.full_sl:
                self._close_position(price, "full_sl", dt)

        elif self._state == PositionState.TRAIL:
            pnl_pct = self._calculate_pnl_pct(price)
            self._position['peak_pnl'] = max(
                self._position.get('peak_pnl', 0),
                pnl_pct
            )
            peak = self._position['peak_pnl']

            drawdown = (peak - pnl_pct) / max(peak, 0.001) if peak > 0 else 0

            if drawdown >= self.config.trail_dd or pnl_pct >= self.config.trail_max:
                self._close_position(price, "trail_exit", dt)
            elif pnl_pct <= -self.config.full_sl:
                self._close_position(price, "trail_sl", dt)

    def _calculate_pnl_pct(self, current_price: float) -> float:
        """计算当前盈亏百分比"""
        if not self._position:
            return 0.0
        entry_price = self._position['entry_price']
        direction = self._position['direction']
        return direction * (current_price - entry_price) / entry_price

    def _open_probe(self, price: float, direction: int, dt):
        """开探针仓"""
        self._position = {
            'direction': direction,
            'entry_price': price,
            'entry_time': dt,
            'size': self.config.probe_size,
            'peak_pnl': 0
        }
        self._state = PositionState.PROBE

        direction_str = 'BUY' if direction == 1 else 'SELL'
        self._log("LSTM", "INFO", f"开探针仓: {direction_str} @ {price:.2f}")

        # CTP下单
        self.system.send_order(
            instrument_id=self.config.instrument_id,
            direction=direction_str,
            offset='OPEN',
            price=price,
            volume=int(self.config.probe_size)
        )

    def _upgrade_to_full(self, price: float, dt):
        """探针升满仓"""
        add_size = self.config.full_size - self.config.probe_size

        self._position['entry_price'] = price
        self._position['size'] = self.config.full_size
        self._position['peak_pnl'] = 0
        self._state = PositionState.FULL

        direction_str = 'BUY' if self._position['direction'] == 1 else 'SELL'
        self._log("LSTM", "INFO", f"升级满仓: {direction_str} +{add_size} @ {price:.2f}")

        # 加仓
        self.system.send_order(
            instrument_id=self.config.instrument_id,
            direction=direction_str,
            offset='OPEN',
            price=price,
            volume=int(add_size)
        )

    def _upgrade_to_trail(self, dt):
        """满仓转追踪"""
        self._state = PositionState.TRAIL
        self._log("LSTM", "INFO", f"启动追踪止盈, 当前盈利={self._position['peak_pnl']*100:.2f}%")

    def _close_position(self, price: float, reason: str, dt):
        """平仓"""
        pnl_pct = self._calculate_pnl_pct(price)
        cost = self.config.commission_rate * 2 + self.config.slippage * 2
        net_pnl = pnl_pct * self._position['size'] - cost

        self._log("LSTM", "INFO",
            f"平仓: {reason}, 净收益={net_pnl*100:.4f}%")

        # CTP平仓
        direction = self._position['direction']
        close_direction = 'SELL' if direction == 1 else 'BUY'

        self.system.send_order(
            instrument_id=self.config.instrument_id,
            direction=close_direction,
            offset='CLOSE',
            price=price,
            volume=int(self._position['size'])
        )

        self._position = None
        self._state = PositionState.FLAT

    def _log(self, source: str, level: str, message: str):
        if self._log_callback:
            self._log_callback(source, level, message)

    def start(self) -> bool:
        """启动策略"""
        if not self.load_model():
            return False
        self._running = True
        self._state = PositionState.FLAT
        self._feature_buffer = []
        return True

    def stop(self):
        """停止策略"""
        self._running = False

    def get_status(self) -> dict:
        return {
            'name': 'LSTM_L2',
            'running': self._running,
            'state': self._state.value,
            'position': self._position
        }
```

### 5.2 特征工程模块

```python
# ctp_trading_system/strategy/lstm_l2/feature_engine.py

import numpy as np
from collections import deque
from typing import Dict, List
from dataclasses import dataclass

@dataclass
class FeatureConfig:
    """特征工程配置"""
    lookback_5min: int = 5
    lookback_15min: int = 15
    lookback_30min: int = 30
    rsi_period: int = 14


class FeatureEngine:
    """
    特征工程引擎
    来源: feature_engineering.py + iceberg_detection.py + large_order_detection.py

    生成93个特征用于LSTM预测
    """

    def __init__(self, config: FeatureConfig = None):
        self.config = config or FeatureConfig()
        self._bar_buffer = deque(maxlen=60)  # 60分钟历史
        self._tick_buffer = deque(maxlen=1000)  # 1000个tick

    def calculate_features(self, bar_data: dict) -> Dict[str, float]:
        """
        计算完整特征集 (93个特征)

        特征分类:
        A. 基础OHLCV特征 (~30个)
        B. 订单流特征 (~15个)
        C. 冰山单特征 (~7个)
        D. 大单特征 (~6个)
        E. 技术指标 (~20个)
        F. 滞后特征 (~15个)
        """
        self._bar_buffer.append(bar_data)
        bars = list(self._bar_buffer)

        features = {}

        # A. 基础OHLCV
        features.update(self._calc_ohlcv_features(bars))

        # B. 订单流特征
        features.update(self._calc_orderflow_features(bars))

        # C. 冰山单特征 (需要tick数据)
        features.update(self._calc_iceberg_features())

        # D. 大单特征
        features.update(self._calc_large_order_features())

        # E. 技术指标
        features.update(self._calc_technical_indicators(bars))

        # F. 滞后特征
        features.update(self._calc_lag_features(bars))

        return features

    def _calc_ohlcv_features(self, bars: List[dict]) -> Dict[str, float]:
        """基础OHLCV特征"""
        features = {}

        if len(bars) < 2:
            return {f'return_{i}min': 0.0 for i in [1, 5, 15, 30]}

        closes = [b['close'] for b in bars]
        highs = [b['high'] for b in bars]
        lows = [b['low'] for b in bars]
        volumes = [b['volume'] for b in bars]

        # 收益率
        features['return_1min'] = (closes[-1] - closes[-2]) / closes[-2] if len(closes) >= 2 else 0
        features['return_5min'] = (closes[-1] - closes[-5]) / closes[-5] if len(closes) >= 5 else 0
        features['return_15min'] = (closes[-1] - closes[-15]) / closes[-15] if len(closes) >= 15 else 0
        features['return_30min'] = (closes[-1] - closes[-30]) / closes[-30] if len(closes) >= 30 else 0

        # 波动率
        if len(closes) >= 5:
            returns = np.diff(closes[-5:]) / np.array(closes[-5:-1])
            features['volatility_5min'] = np.std(returns) if len(returns) > 0 else 0
        else:
            features['volatility_5min'] = 0

        # 范围
        features['range_5min'] = (max(highs[-5:]) - min(lows[-5:])) / closes[-1] if len(bars) >= 5 else 0

        # 成交量
        features['volume_sum'] = sum(volumes[-5:]) if len(volumes) >= 5 else 0
        features['volume_ratio'] = volumes[-1] / np.mean(volumes[-20:]) if len(volumes) >= 20 else 1

        return features

    def _calc_orderflow_features(self, bars: List[dict]) -> Dict[str, float]:
        """订单流特征"""
        # 简化版本,实际需要tick级别数据
        return {
            'tick_imbalance': 0.0,
            'volume_imbalance': 0.0,
            'aggressive_buy_ratio': 0.5,
            'aggressive_sell_ratio': 0.5,
            'net_aggressive_ratio': 0.0
        }

    def _calc_iceberg_features(self) -> Dict[str, float]:
        """
        冰山单特征
        来源: iceberg_detection.py
        """
        return {
            'iceberg_imbalance': 0.0,
            'bid_iceberg_strength': 0.0,
            'ask_iceberg_strength': 0.0,
            'has_bid_iceberg': 0,
            'has_ask_iceberg': 0,
            'bid_iceberg_count': 0,
            'ask_iceberg_count': 0
        }

    def _calc_large_order_features(self) -> Dict[str, float]:
        """
        大单特征
        来源: large_order_detection.py
        """
        return {
            'large_order_ratio': 0.0,
            'large_order_imbalance': 0.0,
            'large_buy_count': 0,
            'large_sell_count': 0,
            'large_buy_volume': 0.0,
            'large_sell_volume': 0.0
        }

    def _calc_technical_indicators(self, bars: List[dict]) -> Dict[str, float]:
        """技术指标"""
        features = {}

        if len(bars) < 14:
            return {
                'rsi_14': 50.0,
                'ema_10': 0.0,
                'ema_30': 0.0,
                'momentum_5': 0.0
            }

        closes = np.array([b['close'] for b in bars])

        # RSI
        features['rsi_14'] = self._calc_rsi(closes, 14)

        # EMA
        features['ema_10'] = self._calc_ema(closes, 10)[-1]
        features['ema_30'] = self._calc_ema(closes, 30)[-1] if len(closes) >= 30 else closes[-1]

        # Momentum
        features['momentum_5'] = closes[-1] - closes[-5] if len(closes) >= 5 else 0

        return features

    def _calc_lag_features(self, bars: List[dict]) -> Dict[str, float]:
        """滞后特征"""
        features = {}

        if len(bars) < 4:
            return {f'return_lag{i}': 0.0 for i in range(1, 4)}

        closes = [b['close'] for b in bars]

        for i in range(1, 4):
            if len(closes) > i + 1:
                features[f'return_lag{i}'] = (closes[-i-1] - closes[-i-2]) / closes[-i-2]
            else:
                features[f'return_lag{i}'] = 0.0

        return features

    def _calc_rsi(self, prices: np.ndarray, period: int = 14) -> float:
        """计算RSI"""
        if len(prices) < period + 1:
            return 50.0

        deltas = np.diff(prices)
        gains = np.where(deltas > 0, deltas, 0)
        losses = np.where(deltas < 0, -deltas, 0)

        avg_gain = np.mean(gains[-period:])
        avg_loss = np.mean(losses[-period:])

        if avg_loss == 0:
            return 100.0

        rs = avg_gain / avg_loss
        return 100 - (100 / (1 + rs))

    def _calc_ema(self, prices: np.ndarray, period: int) -> np.ndarray:
        """计算EMA"""
        alpha = 2 / (period + 1)
        ema = np.zeros_like(prices)
        ema[0] = prices[0]
        for i in range(1, len(prices)):
            ema[i] = alpha * prices[i] + (1 - alpha) * ema[i-1]
        return ema

    def add_tick(self, tick_data: dict):
        """添加tick数据用于订单流分析"""
        self._tick_buffer.append(tick_data)
```

---

## 六、交易记录存储

### 6.1 数据模型 (整合两个策略的TradeDetail)

```python
# ctp_trading_system/storage/models.py

from dataclasses import dataclass, field, asdict
from typing import Optional, Dict, Any
from datetime import datetime
from enum import Enum

class TradeDirection(Enum):
    LONG = 1
    SHORT = -1

class ExitReason(Enum):
    STOP_LOSS = "stop_loss"
    TAKE_PROFIT = "take_profit"
    TRAIL_STOP = "trail_stop"
    IMB_REVERSAL = "imb_reversal"
    TIMEOUT = "timeout"
    MANUAL = "manual"
    PROBE_SL = "probe_sl"
    FULL_SL = "full_sl"
    TRAIL_EXIT = "trail_exit"

@dataclass
class TradeRecord:
    """
    统一交易记录模型
    整合自:
    - L2滑点回测.py TradeDetail (80+字段)
    - tick_timeframe_test.py TickTradeDetail
    """

    # ========== A. 定位与标识 ==========
    id: Optional[int] = None              # 数据库主键
    trade_id: int = 0                     # 策略内序号
    global_id: str = ""                   # 全局唯一ID
    strategy_name: str = ""               # 策略名: H1e_TICK / LSTM_L2
    config_name: str = ""                 # 配置名称
    symbol: str = ""                      # 合约代码
    run_id: str = ""                      # 运行批次ID

    # ========== B. 时间字段 ==========
    signal_datetime: Optional[datetime] = None  # 信号时间
    entry_datetime: Optional[datetime] = None   # 入场时间
    exit_datetime: Optional[datetime] = None    # 出场时间
    signal_timestamp_ms: int = 0          # 信号毫秒时间戳
    entry_timestamp_ms: int = 0           # 入场毫秒时间戳
    exit_timestamp_ms: int = 0            # 出场毫秒时间戳

    # ========== C. 方向与仓位 ==========
    direction: int = 0                    # 1=多, -1=空
    volume: int = 1                       # 手数
    position_state: str = ""              # 仓位状态: probe/full/trail
    hold_duration_seconds: float = 0      # 持仓时长(秒)
    hold_bars: int = 0                    # 持仓bar数 (LSTM)
    hold_ticks: int = 0                   # 持仓tick数 (H1e)

    # ========== D. 价格与执行 ==========
    signal_price: float = 0.0             # 信号价格
    entry_price: float = 0.0              # 成交价格
    exit_price: float = 0.0               # 平仓价格
    highest_price: float = 0.0            # 持仓期最高价
    lowest_price: float = 0.0             # 持仓期最低价

    # ========== E. 信号质量 (策略特有) ==========
    entry_imb: float = 0.0                # H1e: IMB值
    entry_prob: float = 0.5               # LSTM: 预测概率
    signal_strength: str = ""             # 信号强度: weak/medium/strong
    entry_depth: int = 0                  # 盘口深度
    entry_volatility: float = 0.0         # 入场波动率
    entry_rsi: float = 50.0               # RSI值

    # ========== F. 收益与成本 ==========
    pnl_ticks: float = 0.0                # 盈亏跳数
    gross_pnl_pct: float = 0.0            # 毛收益%
    net_pnl_pct: float = 0.0              # 净收益%
    commission: float = 0.0               # 手续费
    slippage_pct: float = 0.0             # 滑点%
    total_cost_pct: float = 0.0           # 总成本%

    # ========== G. MAE/MFE ==========
    mae_pct: float = 0.0                  # 最大不利偏移%
    mfe_pct: float = 0.0                  # 最大有利偏移%
    r_multiple: float = 0.0               # R倍数

    # ========== H. 退出状态 ==========
    exit_reason: str = ""                 # 退出原因
    final_state: str = ""                 # completed/cancelled/error

    # ========== I. CTP订单关联 ==========
    entry_order_ref: str = ""             # 入场报单引用
    exit_order_ref: str = ""              # 平仓报单引用
    entry_order_sys_id: str = ""          # 交易所入场单号
    exit_order_sys_id: str = ""           # 交易所平仓单号

    # ========== J. 扩展数据 (JSON) ==========
    l2_snapshot_entry: Optional[Dict] = None   # 入场L2盘口快照
    l2_snapshot_exit: Optional[Dict] = None    # 出场L2盘口快照
    extra_data: Optional[Dict] = None          # 其他扩展数据

    # ========== K. 元数据 ==========
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None

    def to_dict(self) -> Dict[str, Any]:
        """转换为字典"""
        return asdict(self)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'TradeRecord':
        """从字典创建"""
        return cls(**{k: v for k, v in data.items() if k in cls.__dataclass_fields__})
```

### 6.2 数据库管理

```python
# ctp_trading_system/storage/database.py

import sqlite3
import json
from pathlib import Path
from datetime import datetime
from typing import List, Optional
from contextlib import contextmanager

from .models import TradeRecord

class TradeDatabase:
    """交易记录数据库管理"""

    def __init__(self, db_path: str = None):
        if db_path is None:
            db_path = Path(__file__).parent.parent / "data" / "trades.db"
        self.db_path = Path(db_path)
        self.db_path.parent.mkdir(parents=True, exist_ok=True)
        self._init_db()

    def _init_db(self):
        """初始化数据库表"""
        with self._get_connection() as conn:
            conn.execute('''
                CREATE TABLE IF NOT EXISTS trades (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    trade_id INTEGER,
                    global_id TEXT UNIQUE,
                    strategy_name TEXT,
                    config_name TEXT,
                    symbol TEXT,
                    run_id TEXT,

                    signal_datetime TEXT,
                    entry_datetime TEXT,
                    exit_datetime TEXT,
                    signal_timestamp_ms INTEGER,
                    entry_timestamp_ms INTEGER,
                    exit_timestamp_ms INTEGER,

                    direction INTEGER,
                    volume INTEGER,
                    position_state TEXT,
                    hold_duration_seconds REAL,
                    hold_bars INTEGER,
                    hold_ticks INTEGER,

                    signal_price REAL,
                    entry_price REAL,
                    exit_price REAL,
                    highest_price REAL,
                    lowest_price REAL,

                    entry_imb REAL,
                    entry_prob REAL,
                    signal_strength TEXT,
                    entry_depth INTEGER,
                    entry_volatility REAL,
                    entry_rsi REAL,

                    pnl_ticks REAL,
                    gross_pnl_pct REAL,
                    net_pnl_pct REAL,
                    commission REAL,
                    slippage_pct REAL,
                    total_cost_pct REAL,

                    mae_pct REAL,
                    mfe_pct REAL,
                    r_multiple REAL,

                    exit_reason TEXT,
                    final_state TEXT,

                    entry_order_ref TEXT,
                    exit_order_ref TEXT,
                    entry_order_sys_id TEXT,
                    exit_order_sys_id TEXT,

                    l2_snapshot_entry TEXT,
                    l2_snapshot_exit TEXT,
                    extra_data TEXT,

                    created_at TEXT DEFAULT CURRENT_TIMESTAMP,
                    updated_at TEXT DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # 索引
            conn.execute('CREATE INDEX IF NOT EXISTS idx_strategy ON trades(strategy_name)')
            conn.execute('CREATE INDEX IF NOT EXISTS idx_symbol ON trades(symbol)')
            conn.execute('CREATE INDEX IF NOT EXISTS idx_entry_datetime ON trades(entry_datetime)')
            conn.execute('CREATE INDEX IF NOT EXISTS idx_run_id ON trades(run_id)')

            conn.commit()

    @contextmanager
    def _get_connection(self):
        """获取数据库连接"""
        conn = sqlite3.connect(str(self.db_path))
        conn.row_factory = sqlite3.Row
        try:
            yield conn
        finally:
            conn.close()

    def insert_trade(self, trade: TradeRecord) -> int:
        """插入交易记录"""
        data = trade.to_dict()

        # JSON序列化
        for key in ['l2_snapshot_entry', 'l2_snapshot_exit', 'extra_data']:
            if data.get(key):
                data[key] = json.dumps(data[key])

        # 时间格式化
        for key in ['signal_datetime', 'entry_datetime', 'exit_datetime']:
            if data.get(key) and isinstance(data[key], datetime):
                data[key] = data[key].isoformat()

        columns = [k for k in data.keys() if k != 'id']
        placeholders = ', '.join(['?' for _ in columns])
        column_names = ', '.join(columns)

        with self._get_connection() as conn:
            cursor = conn.execute(
                f'INSERT INTO trades ({column_names}) VALUES ({placeholders})',
                [data[k] for k in columns]
            )
            conn.commit()
            return cursor.lastrowid

    def get_trades_by_strategy(self, strategy_name: str,
                                start_date: str = None,
                                end_date: str = None) -> List[TradeRecord]:
        """按策略查询交易记录"""
        query = 'SELECT * FROM trades WHERE strategy_name = ?'
        params = [strategy_name]

        if start_date:
            query += ' AND entry_datetime >= ?'
            params.append(start_date)
        if end_date:
            query += ' AND entry_datetime <= ?'
            params.append(end_date)

        query += ' ORDER BY entry_datetime'

        with self._get_connection() as conn:
            rows = conn.execute(query, params).fetchall()
            return [self._row_to_trade(row) for row in rows]

    def get_daily_summary(self, date: str, strategy_name: str = None) -> dict:
        """获取日统计"""
        query = '''
            SELECT
                COUNT(*) as total_trades,
                SUM(CASE WHEN net_pnl_pct > 0 THEN 1 ELSE 0 END) as winning_trades,
                SUM(net_pnl_pct) as total_pnl_pct,
                AVG(net_pnl_pct) as avg_pnl_pct,
                MIN(net_pnl_pct) as min_pnl_pct,
                MAX(net_pnl_pct) as max_pnl_pct
            FROM trades
            WHERE date(entry_datetime) = ?
        '''
        params = [date]

        if strategy_name:
            query += ' AND strategy_name = ?'
            params.append(strategy_name)

        with self._get_connection() as conn:
            row = conn.execute(query, params).fetchone()
            return dict(row) if row else {}

    def export_to_csv(self, output_path: str, strategy_name: str = None):
        """导出CSV"""
        import csv

        query = 'SELECT * FROM trades'
        params = []
        if strategy_name:
            query += ' WHERE strategy_name = ?'
            params.append(strategy_name)
        query += ' ORDER BY entry_datetime'

        with self._get_connection() as conn:
            rows = conn.execute(query, params).fetchall()

            if not rows:
                return

            with open(output_path, 'w', newline='', encoding='utf-8') as f:
                writer = csv.writer(f)
                writer.writerow(rows[0].keys())
                for row in rows:
                    writer.writerow(row)

    def _row_to_trade(self, row: sqlite3.Row) -> TradeRecord:
        """将数据库行转换为TradeRecord"""
        data = dict(row)

        # JSON反序列化
        for key in ['l2_snapshot_entry', 'l2_snapshot_exit', 'extra_data']:
            if data.get(key):
                data[key] = json.loads(data[key])

        return TradeRecord.from_dict(data)
```

---

## 七、策略管理器

```python
# ctp_trading_system/strategy/strategy_manager.py

from typing import Dict, Optional, List
from enum import Enum
from dataclasses import dataclass

from .base_strategy import BaseStrategy
from .h1e_tick.h1e_strategy import H1eTickStrategy, H1eConfig
from .lstm_l2.lstm_strategy import LSTML2Strategy, LSTMConfig


class StrategyType(Enum):
    H1E_TICK = "H1e_TICK"
    LSTM_L2 = "LSTM_L2"
    DEMO_AUTO = "DEMO_AUTO"


@dataclass
class StrategyAllocation:
    """仓位分配"""
    strategy_type: StrategyType
    allocation_pct: float  # 仓位占比 (0-1)
    max_position: int      # 最大持仓手数


class StrategyManager:
    """
    策略管理器

    功能:
    1. 策略注册与管理
    2. 手动切换策略
    3. 同时运行多策略
    4. 仓位分配控制
    """

    def __init__(self, trading_system):
        self.system = trading_system
        self._strategies: Dict[str, BaseStrategy] = {}
        self._allocations: Dict[str, StrategyAllocation] = {}
        self._active_strategies: List[str] = []

    def register_strategy(self,
                          strategy_type: StrategyType,
                          config: dict,
                          allocation: StrategyAllocation = None):
        """注册策略"""
        name = strategy_type.value

        if strategy_type == StrategyType.H1E_TICK:
            h1e_config = H1eConfig(**config)
            self._strategies[name] = H1eTickStrategy(self.system, h1e_config)

        elif strategy_type == StrategyType.LSTM_L2:
            lstm_config = LSTMConfig(**config)
            self._strategies[name] = LSTML2Strategy(self.system, lstm_config)

        if allocation:
            self._allocations[name] = allocation

    def start_strategy(self, name: str) -> bool:
        """启动指定策略"""
        if name not in self._strategies:
            return False

        strategy = self._strategies[name]
        success = strategy.start()

        if success and name not in self._active_strategies:
            self._active_strategies.append(name)

        return success

    def stop_strategy(self, name: str) -> bool:
        """停止指定策略"""
        if name not in self._strategies:
            return False

        strategy = self._strategies[name]
        strategy.stop()

        if name in self._active_strategies:
            self._active_strategies.remove(name)

        return True

    def switch_strategy(self, from_name: str, to_name: str) -> bool:
        """
        切换策略 (手动)

        1. 停止当前策略
        2. 等待平仓完成
        3. 启动新策略
        """
        if from_name in self._active_strategies:
            self.stop_strategy(from_name)

        return self.start_strategy(to_name)

    def set_allocation(self, name: str, allocation_pct: float, max_position: int):
        """设置仓位分配"""
        if name in self._strategies:
            self._allocations[name] = StrategyAllocation(
                strategy_type=StrategyType(name),
                allocation_pct=allocation_pct,
                max_position=max_position
            )

    def get_active_strategies(self) -> List[str]:
        """获取运行中的策略列表"""
        return self._active_strategies.copy()

    def get_all_status(self) -> Dict[str, dict]:
        """获取所有策略状态"""
        status = {}
        for name, strategy in self._strategies.items():
            status[name] = {
                **strategy.get_status(),
                'active': name in self._active_strategies,
                'allocation': self._allocations.get(name)
            }
        return status

    def on_tick(self, tick_data: dict):
        """Tick数据分发给活跃策略"""
        for name in self._active_strategies:
            strategy = self._strategies.get(name)
            if strategy and hasattr(strategy, 'on_tick'):
                strategy.on_tick(tick_data)

    def on_bar(self, bar_data: dict):
        """Bar数据分发给活跃策略"""
        for name in self._active_strategies:
            strategy = self._strategies.get(name)
            if strategy and hasattr(strategy, 'on_bar'):
                strategy.on_bar(bar_data)
```

---

## 八、风控引擎

```python
# ctp_trading_system/risk/risk_engine.py

from dataclasses import dataclass
from datetime import datetime, time
from typing import List, Tuple, Optional

@dataclass
class RiskConfig:
    """风控配置"""
    # 日内风控
    daily_stop_loss_pct: float = -0.007    # 日亏-0.7%停止
    max_daily_trades: int = 500
    max_consecutive_losses: int = 10

    # 单笔风控
    max_single_loss_pct: float = -0.005    # 单笔最大亏损-0.5%
    max_position_value: float = 100000     # 最大持仓金额

    # 交易时段
    trading_sessions: List[Tuple[time, time]] = None
    enable_night_session: bool = True

    def __post_init__(self):
        if self.trading_sessions is None:
            self.trading_sessions = [
                (time(9, 0), time(10, 15)),
                (time(10, 30), time(11, 30)),
                (time(13, 30), time(15, 0)),
                (time(21, 0), time(23, 0)),
            ]


class RiskEngine:
    """
    风控引擎
    来源: production_config.py
    """

    def __init__(self, config: RiskConfig = None):
        self.config = config or RiskConfig()
        self._daily_pnl = 0.0
        self._daily_trades = 0
        self._consecutive_losses = 0
        self._last_trade_date = None
        self._trading_paused = False

    def reset_daily(self):
        """每日重置"""
        self._daily_pnl = 0.0
        self._daily_trades = 0
        self._consecutive_losses = 0
        self._trading_paused = False

    def check_trade_allowed(self) -> Tuple[bool, str]:
        """检查是否允许交易"""
        now = datetime.now()

        # 检查日期变化
        if self._last_trade_date != now.date():
            self.reset_daily()
            self._last_trade_date = now.date()

        # 检查交易时段
        if not self._is_trading_time(now.time()):
            return False, "非交易时段"

        # 检查是否暂停
        if self._trading_paused:
            return False, "交易已暂停"

        # 检查日亏损
        if self._daily_pnl <= self.config.daily_stop_loss_pct:
            self._trading_paused = True
            return False, f"日亏损达到{self._daily_pnl*100:.2f}%"

        # 检查日交易数
        if self._daily_trades >= self.config.max_daily_trades:
            return False, f"日交易数达到{self._daily_trades}"

        # 检查连续亏损
        if self._consecutive_losses >= self.config.max_consecutive_losses:
            return False, f"连续亏损{self._consecutive_losses}次"

        return True, "OK"

    def record_trade(self, pnl_pct: float):
        """记录交易结果"""
        self._daily_pnl += pnl_pct
        self._daily_trades += 1

        if pnl_pct < 0:
            self._consecutive_losses += 1
        else:
            self._consecutive_losses = 0

    def _is_trading_time(self, t: time) -> bool:
        """检查是否在交易时段"""
        for start, end in self.config.trading_sessions:
            if start <= t <= end:
                return True
        return False

    def get_status(self) -> dict:
        """获取风控状态"""
        return {
            'daily_pnl': self._daily_pnl,
            'daily_trades': self._daily_trades,
            'consecutive_losses': self._consecutive_losses,
            'trading_paused': self._trading_paused
        }
```

---

## 九、API扩展

```python
# ctp_trading_system/web/api/strategy.py (扩展)

from fastapi import APIRouter
from pydantic import BaseModel
from typing import Optional, Dict, List

router = APIRouter()

class StrategyStartRequest(BaseModel):
    """启动策略请求"""
    strategy_name: str  # H1e_TICK / LSTM_L2
    config: Optional[Dict] = None
    allocation_pct: float = 1.0
    max_position: int = 1

class AllocationRequest(BaseModel):
    """仓位分配请求"""
    allocations: Dict[str, float]  # {策略名: 占比}

@router.post("/start/{strategy_name}")
async def start_strategy(strategy_name: str, request: StrategyStartRequest):
    """启动指定策略"""
    manager = get_strategy_manager()
    success = manager.start_strategy(strategy_name)
    return {"success": success, "message": f"策略 {strategy_name} 启动" if success else "启动失败"}

@router.post("/stop/{strategy_name}")
async def stop_strategy(strategy_name: str):
    """停止指定策略"""
    manager = get_strategy_manager()
    success = manager.stop_strategy(strategy_name)
    return {"success": success}

@router.post("/switch")
async def switch_strategy(from_name: str, to_name: str):
    """切换策略"""
    manager = get_strategy_manager()
    success = manager.switch_strategy(from_name, to_name)
    return {"success": success}

@router.post("/allocation")
async def set_allocation(request: AllocationRequest):
    """设置仓位分配"""
    manager = get_strategy_manager()
    for name, pct in request.allocations.items():
        manager.set_allocation(name, pct, max_position=int(pct * 10))
    return {"success": True}

@router.get("/status")
async def get_all_status():
    """获取所有策略状态"""
    manager = get_strategy_manager()
    return {"data": manager.get_all_status()}

@router.get("/active")
async def get_active_strategies():
    """获取运行中策略列表"""
    manager = get_strategy_manager()
    return {"data": manager.get_active_strategies()}
```

---

## 十、实现路线图

### Phase 1: 基础框架 (预计工作量: 中)
- [ ] 创建目录结构
- [ ] 实现TradeRecord数据模型
- [ ] 实现SQLite数据库管理
- [ ] 实现StrategyManager基础框架

### Phase 2: H1e Tick策略 (预计工作量: 大)
- [ ] 移植IMB计算逻辑
- [ ] 实现V4利润奔跑出场规则
- [ ] 实现日内风控
- [ ] 对接CTP实时行情
- [ ] 回测验证收益一致性

### Phase 3: LSTM策略 (预计工作量: 大)
- [ ] 移植LSTM模型加载
- [ ] 实现特征工程
- [ ] 实现状态机交易逻辑
- [ ] 对接CTP分钟Bar
- [ ] 回测验证收益一致性

### Phase 4: 集成测试 (预计工作量: 中)
- [ ] 策略切换测试
- [ ] 同时运行测试
- [ ] 仓位分配测试
- [ ] 交易记录存储测试

### Phase 5: UI扩展 (预计工作量: 小)
- [ ] 策略选择面板
- [ ] 仓位配置界面
- [ ] 交易记录查询
- [ ] 收益统计图表

---

## 十一、关键依赖

### 模型文件 (必须)
```
C:\Repo\future-trading-strategy\experiments\model_cache_tick\
├── 90f7e5a7810b_lstm_model.pt    # LSTM模型权重
└── 90f7e5a7810b_lstm_scaler.pkl  # 特征标准化器
```

### 特征数据 (可选,用于冰山/大单特征)
```
C:\ProcessedData\
├── iceberg_experiment\iceberg_features_all.parquet
├── large_order_experiment\large_order_features_all.parquet
└── volatility_experiment\volatility_features.parquet
```

### Python依赖
```
torch>=1.9.0
numpy>=1.19.0
pandas>=1.3.0
scikit-learn>=0.24.0  # Scaler
```

---

## 十二、风险说明

1. **收益不保证**: 回测收益不代表实盘收益，市场条件变化可能导致策略失效
2. **滑点影响**: 实盘滑点可能高于回测假设，特别是H1e高频策略
3. **网络延迟**: CTP网络延迟可能影响H1e策略的信号时效性
4. **模型泛化**: LSTM模型在新数据上的表现可能不如训练期
5. **仓位管理**: 同时运行多策略时需严格控制总仓位

---

**审核人**: _________________
**审核日期**: _________________
**审核意见**: _________________
