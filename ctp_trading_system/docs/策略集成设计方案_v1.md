# CTP程序化交易系统 - 策略集成设计方案

**版本**: v1.2
**日期**: 2026-01-27
**状态**: 待审核

**更新记录**:
- v1.2 (2026-01-27): 补充缓存组件实现(BarAggregator, L2DepthBuffer, FeatureSequenceCache)
- v1.1 (2026-01-27): 新增第十章"实盘数据缓存与备份设计"，整合双流架构
- v1.0 (2026-01-26): 初版，策略集成框架设计

---

## 一、项目目标

将两个经过回测验证的高收益策略集成到CTP程序化交易系统：

| 策略 | 累计收益 | 交易笔数 | 特点 |
|------|---------|---------|------|
| H1e Tick | +13,706% | 67,926笔/16月 | IMB信号、秒级持仓、日复利 |
| LSTM L2 | +2,618% | 1,340笔/16月 | 深度学习、分钟级持仓、月复利 |

**核心要求**:
1. 策略代码基于原始回测验证的实现
2. 保持与原回测相同的收益表现
3. 支持手动切换和同时运行
4. 可配置仓位分配

---

## 二、系统架构

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         CTP 程序化交易系统                               │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐                 │
│  │  Web UI     │    │  策略管理器  │    │  风控引擎   │                 │
│  │  (FastAPI)  │◄──►│  (Manager)  │◄──►│  (Risk)    │                 │
│  └─────────────┘    └──────┬──────┘    └─────────────┘                 │
│                            │                                            │
│         ┌──────────────────┼──────────────────┐                        │
│         ▼                  ▼                  ▼                        │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐                 │
│  │ H1e Tick    │    │ LSTM L2     │    │ Demo Auto   │                 │
│  │ Strategy    │    │ Strategy    │    │ Strategy    │                 │
│  └──────┬──────┘    └──────┬──────┘    └──────┬──────┘                 │
│         │                  │                  │                        │
│         └──────────────────┼──────────────────┘                        │
│                            ▼                                            │
│                   ┌─────────────┐                                       │
│                   │ CTP Gateway │                                       │
│                   │ (交易网关)  │                                       │
│                   └──────┬──────┘                                       │
│                          │                                              │
│         ┌────────────────┼────────────────┐                            │
│         ▼                ▼                ▼                            │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐                     │
│  │ 行情订阅    │  │ 交易执行    │  │ 持仓查询    │                     │
│  │ (MD API)   │  │ (TD API)   │  │ (Query)    │                     │
│  └─────────────┘  └─────────────┘  └─────────────┘                     │
│                                                                         │
├─────────────────────────────────────────────────────────────────────────┤
│                         数据存储层                                       │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐                     │
│  │ trades.db   │  │ logs/       │  │ models/     │                     │
│  │ (SQLite)    │  │ (日志文件)  │  │ (LSTM模型)  │                     │
│  └─────────────┘  └─────────────┘  └─────────────┘                     │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 三、目录结构

```
ctp_trading_system/
├── strategy/
│   ├── __init__.py
│   ├── base_strategy.py          # 策略基类 (已有)
│   ├── demo_strategy.py          # 演示策略 (已有)
│   ├── strategy_manager.py       # [新增] 策略管理器
│   │
│   ├── h1e_tick/                 # [新增] H1e Tick策略
│   │   ├── __init__.py
│   │   ├── h1e_strategy.py       # 核心策略实现
│   │   ├── imb_calculator.py     # IMB信号计算
│   │   └── config.py             # 策略配置
│   │
│   └── lstm_l2/                  # [新增] LSTM L2策略
│       ├── __init__.py
│       ├── lstm_strategy.py      # 核心策略实现
│       ├── feature_engine.py     # 特征工程
│       ├── model_loader.py       # 模型加载器
│       └── config.py             # 策略配置
│
├── storage/                      # [新增] 数据存储
│   ├── __init__.py
│   ├── database.py               # SQLite数据库管理
│   ├── models.py                 # TradeRecord数据模型
│   └── trade_repository.py       # CRUD操作
│
├── risk/                         # [新增] 风控模块
│   ├── __init__.py
│   ├── risk_engine.py            # 风控引擎
│   └── daily_control.py          # 日内风控
│
└── web/
    └── api/
        └── strategy.py           # 策略API (已有，需扩展)
```

---

## 四、H1e Tick策略实现

### 4.1 核心逻辑 (来源: tick_strategy_v4_profit_run.py)

```python
# ctp_trading_system/strategy/h1e_tick/h1e_strategy.py

from dataclasses import dataclass
from typing import Optional, Tuple, Callable
from enum import Enum

class ExitReason(Enum):
    IMB_REVERSAL = "imb_reversal"    # 动力反转
    TRAIL_STOP = "trail_stop"        # 追踪止盈
    STOP_LOSS = "stop_loss"          # 止损
    TIMEOUT = "timeout"              # 超时
    MANUAL = "manual"                # 手动平仓

@dataclass
class H1eConfig:
    """H1e策略配置 - 来源: production_config.py"""
    # 入场条件
    imb_threshold: float = 0.8        # IMB触发阈值
    min_depth: int = 1500             # 最小盘口深度
    max_volatility: float = 0.00015   # 最大波动率
    signal_cooldown: int = 10         # 信号冷却(tick数)

    # 退出条件
    imb_exit_threshold: float = 0.2   # IMB反转退出阈值
    trail_trigger_ticks: float = 2.0  # 追踪止盈触发(tick)
    trail_stop_ticks: float = 1.0     # 追踪止盈止损(tick)
    stop_loss_ticks: float = 2.0      # 硬止损(tick)
    max_hold_ticks: int = 30          # 最大持仓(tick数)

    # 日内风控
    daily_stop_loss_pct: float = -0.007  # 日亏-0.7%停止
    max_daily_trades: int = 500

    # 合约参数
    tick_size: float = 1.0            # 最小变动价位
    commission_rate: float = 0.00005  # 手续费率


class H1eTickStrategy:
    """
    H1e Tick策略 - 基于IMB订单流不平衡信号

    原始收益: +13,706% (16个月, 67,926笔交易)
    核心逻辑来源: tick_strategy_v4_profit_run.py
    """

    def __init__(self, trading_system, config: H1eConfig):
        self.system = trading_system
        self.config = config
        self._running = False
        self._position = None          # 当前持仓
        self._last_signal_idx = -100   # 上次信号索引
        self._daily_pnl = 0.0          # 日内盈亏
        self._daily_trades = 0         # 日内交易数
        self._tick_buffer = []         # Tick缓冲区
        self._log_callback = None

    def calculate_imb(self, bid_vol: float, ask_vol: float) -> float:
        """
        计算IMB不平衡度
        来源: order_flow_imbalance.py

        公式: imb = (BidVol - AskVol) / (BidVol + AskVol + 1)
        范围: -1 到 +1
        含义: >0.8 买方强势, <-0.8 卖方强势
        """
        return (bid_vol - ask_vol) / (bid_vol + ask_vol + 1)

    def check_entry_signal(self, tick_data: dict) -> Optional[int]:
        """
        检查入场信号

        条件:
        1. |IMB| >= 0.8
        2. 盘口深度 >= 1500
        3. 波动率 <= 0.00015
        4. 冷却期已过

        返回: 1=做多, -1=做空, None=无信号
        """
        imb = tick_data.get('imb', 0)
        depth = tick_data.get('total_depth', 0)
        volatility = tick_data.get('volatility', 0)
        tick_idx = tick_data.get('tick_idx', 0)

        # 冷却期检查
        if tick_idx - self._last_signal_idx < self.config.signal_cooldown:
            return None

        # 条件检查
        if abs(imb) < self.config.imb_threshold:
            return None
        if depth < self.config.min_depth:
            return None
        if volatility > self.config.max_volatility:
            return None

        # 日内风控检查
        if self._daily_pnl <= self.config.daily_stop_loss_pct:
            self._log("RISK", "WARNING", f"日内亏损达到{self._daily_pnl*100:.2f}%, 停止交易")
            return None
        if self._daily_trades >= self.config.max_daily_trades:
            return None

        return 1 if imb > 0 else -1

    def check_exit_signal(self, tick_data: dict) -> Optional[ExitReason]:
        """
        检查出场信号 (V4利润奔跑版)
        来源: tick_strategy_v4_profit_run.py find_next_move_v4()

        规则优先级:
        1. 动力反转 (IMB衰退)
        2. 追踪止盈 (获利回吐)
        3. 止损 (硬止损)
        4. 超时 (强制平仓)
        """
        if not self._position:
            return None

        current_price = tick_data.get('mid_price', 0)
        current_imb = tick_data.get('imb', 0)
        hold_ticks = tick_data.get('tick_idx', 0) - self._position['entry_idx']

        entry_price = self._position['entry_price']
        direction = self._position['direction']

        # 计算盈亏(tick数)
        price_diff = current_price - entry_price
        current_pnl_ticks = price_diff / self.config.tick_size * direction

        # 更新最大盈利
        self._position['max_pnl_ticks'] = max(
            self._position.get('max_pnl_ticks', 0),
            current_pnl_ticks
        )
        max_pnl_ticks = self._position['max_pnl_ticks']

        # 规则1: 动力反转退出
        if direction == 1 and current_imb < self.config.imb_exit_threshold:
            return ExitReason.IMB_REVERSAL
        if direction == -1 and current_imb > -self.config.imb_exit_threshold:
            return ExitReason.IMB_REVERSAL

        # 规则2: 追踪止盈
        if max_pnl_ticks >= self.config.trail_trigger_ticks:
            if current_pnl_ticks <= self.config.trail_stop_ticks:
                return ExitReason.TRAIL_STOP

        # 规则3: 止损
        if current_pnl_ticks <= -self.config.stop_loss_ticks:
            return ExitReason.STOP_LOSS

        # 规则4: 超时
        if hold_ticks >= self.config.max_hold_ticks:
            return ExitReason.TIMEOUT

        return None

    def on_tick(self, tick_data: dict):
        """
        Tick数据回调 - 策略主循环

        tick_data结构:
        {
            'datetime': datetime,
            'last_price': float,
            'bid_price1': float,
            'bid_volume1': int,
            'ask_price1': float,
            'ask_volume1': int,
            'volume': int,
            'tick_idx': int
        }
        """
        if not self._running:
            return

        # 计算IMB和其他特征
        tick_data['imb'] = self.calculate_imb(
            tick_data['bid_volume1'],
            tick_data['ask_volume1']
        )
        tick_data['mid_price'] = (tick_data['bid_price1'] + tick_data['ask_price1']) / 2
        tick_data['total_depth'] = tick_data['bid_volume1'] + tick_data['ask_volume1']

        # 计算波动率 (需要历史数据)
        self._tick_buffer.append(tick_data['mid_price'])
        if len(self._tick_buffer) > 20:
            self._tick_buffer.pop(0)
            returns = [(self._tick_buffer[i] - self._tick_buffer[i-1]) / self._tick_buffer[i-1]
                      for i in range(1, len(self._tick_buffer))]
            tick_data['volatility'] = np.std(returns) if returns else 0
        else:
            tick_data['volatility'] = 0

        # 有持仓时检查出场
        if self._position:
            exit_reason = self.check_exit_signal(tick_data)
            if exit_reason:
                self._close_position(tick_data, exit_reason)
                return

        # 无持仓时检查入场
        else:
            direction = self.check_entry_signal(tick_data)
            if direction:
                self._open_position(tick_data, direction)

    def _open_position(self, tick_data: dict, direction: int):
        """开仓"""
        entry_price = tick_data['mid_price']

        self._position = {
            'direction': direction,
            'entry_price': entry_price,
            'entry_idx': tick_data['tick_idx'],
            'entry_time': tick_data['datetime'],
            'entry_imb': tick_data['imb'],
            'max_pnl_ticks': 0
        }

        self._last_signal_idx = tick_data['tick_idx']
        self._daily_trades += 1

        # 发送CTP开仓指令
        offset = 'OPEN'
        direction_str = 'BUY' if direction == 1 else 'SELL'

        self._log("H1e", "INFO",
            f"开仓信号: {direction_str} @ {entry_price:.2f}, IMB={tick_data['imb']:.3f}")

        # 调用交易系统下单
        self.system.send_order(
            instrument_id=self.config.instrument_id,
            direction=direction_str,
            offset=offset,
            price=entry_price,
            volume=1
        )

    def _close_position(self, tick_data: dict, reason: ExitReason):
        """平仓"""
        exit_price = tick_data['mid_price']
        entry_price = self._position['entry_price']
        direction = self._position['direction']

        # 计算盈亏
        pnl_ticks = (exit_price - entry_price) / self.config.tick_size * direction
        pnl_pct = (exit_price - entry_price) / entry_price * direction
        net_pnl_pct = pnl_pct - self.config.commission_rate * 2

        # 更新日内盈亏
        self._daily_pnl += net_pnl_pct

        self._log("H1e", "INFO",
            f"平仓: {reason.value}, PnL={pnl_ticks:.1f}跳, 净收益={net_pnl_pct*100:.4f}%")

        # 发送CTP平仓指令
        direction_str = 'SELL' if direction == 1 else 'BUY'

        self.system.send_order(
            instrument_id=self.config.instrument_id,
            direction=direction_str,
            offset='CLOSE',
            price=exit_price,
            volume=1
        )

        # 清空持仓
        self._position = None

    def _log(self, source: str, level: str, message: str):
        """日志回调"""
        if self._log_callback:
            self._log_callback(source, level, message)

    def start(self):
        """启动策略"""
        self._running = True
        self._daily_pnl = 0.0
        self._daily_trades = 0
        self._tick_buffer = []
        return True

    def stop(self):
        """停止策略"""
        self._running = False
        if self._position:
            self._log("H1e", "WARNING", "策略停止，强制平仓")
            # 市价平仓逻辑...

    def get_status(self) -> dict:
        """获取状态"""
        return {
            'name': 'H1e_TICK',
            'running': self._running,
            'position': self._position,
            'daily_pnl': self._daily_pnl,
            'daily_trades': self._daily_trades
        }
```

### 4.2 IMB信号计算器

```python
# ctp_trading_system/strategy/h1e_tick/imb_calculator.py

import numpy as np
from collections import deque
from typing import Tuple

class IMBCalculator:
    """
    订单流不平衡度计算器
    来源: order_flow_imbalance.py
    """

    def __init__(self, lookback: int = 20):
        self.lookback = lookback
        self._price_buffer = deque(maxlen=lookback)
        self._imb_buffer = deque(maxlen=lookback)

    def calculate_imb_1(self, bid_vol: float, ask_vol: float) -> float:
        """
        基础IMB: 买卖盘口不平衡

        公式: (BidVol - AskVol) / (BidVol + AskVol + 1)
        范围: [-1, +1]
        """
        denominator = bid_vol + ask_vol + 1
        return (bid_vol - ask_vol) / denominator

    def calculate_volatility(self, mid_price: float) -> float:
        """
        计算20tick滚动波动率
        """
        self._price_buffer.append(mid_price)

        if len(self._price_buffer) < 2:
            return 0.0

        prices = list(self._price_buffer)
        returns = np.diff(prices) / prices[:-1]
        return np.std(returns)

    def calculate_features(self, tick_data: dict) -> dict:
        """
        计算完整特征集

        输入tick_data:
        - bid_price1, bid_volume1
        - ask_price1, ask_volume1
        - last_price, volume

        输出features:
        - imb_1: 基础IMB
        - mid_price: 中间价
        - total_depth: 总深度
        - volatility: 波动率
        - spread: 价差
        """
        bid_vol = tick_data.get('bid_volume1', 0)
        ask_vol = tick_data.get('ask_volume1', 0)
        bid_price = tick_data.get('bid_price1', 0)
        ask_price = tick_data.get('ask_price1', 0)

        mid_price = (bid_price + ask_price) / 2

        features = {
            'imb_1': self.calculate_imb_1(bid_vol, ask_vol),
            'mid_price': mid_price,
            'total_depth': bid_vol + ask_vol,
            'spread': ask_price - bid_price,
            'volatility': self.calculate_volatility(mid_price)
        }

        self._imb_buffer.append(features['imb_1'])

        return features
```

---

## 五、LSTM L2策略实现

### 5.1 核心逻辑 (来源: 纯累积LSTM_带缓存.py)

```python
# ctp_trading_system/strategy/lstm_l2/lstm_strategy.py

import torch
import torch.nn as nn
import numpy as np
import pickle
from dataclasses import dataclass
from typing import Optional, List
from enum import Enum
from pathlib import Path

class PositionState(Enum):
    FLAT = "flat"      # 平仓
    PROBE = "probe"    # 探针仓 (0.3手)
    FULL = "full"      # 满仓 (1手)
    TRAIL = "trail"    # 追踪仓

@dataclass
class LSTMConfig:
    """LSTM策略配置 - 来源: 纯累积LSTM_带缓存.py"""
    # 模型参数
    model_path: str = ""              # LSTM模型路径
    scaler_path: str = ""             # Scaler路径
    seq_len: int = 10                 # 序列长度
    hidden_dim: int = 64              # 隐层维度

    # 信号阈值
    signal_threshold: float = 0.5     # 预测概率阈值
    rsi_upper: float = 60             # RSI上限过滤
    rsi_lower: float = 40             # RSI下限过滤

    # 仓位管理
    probe_size: float = 0.3           # 探针仓位
    full_size: float = 1.0            # 满仓仓位

    # 退出条件
    probe_to_full: float = 0.003      # 探针升满仓阈值 (0.3%)
    probe_sl: float = 0.003           # 探针止损 (0.3%)
    full_to_trail: float = 0.005      # 满仓转追踪 (0.5%)
    full_sl: float = 0.004            # 满仓止损 (0.4%)
    trail_dd: float = 0.30            # 追踪回撤止损 (30%)
    trail_max: float = 0.015          # 追踪最大止盈 (1.5%)

    # 成本
    commission_rate: float = 0.00005  # 手续费率
    slippage: float = 0.00025         # 滑点


class LSTMModel(nn.Module):
    """
    LSTM预测模型
    来源: 纯累积LSTM_带缓存.py

    架构: 双层LSTM (64维隐层) + FC (64->32->1) + Sigmoid
    """

    def __init__(self, input_dim: int, hidden_dim: int = 64, num_layers: int = 2):
        super().__init__()
        self.lstm = nn.LSTM(
            input_dim,
            hidden_dim,
            num_layers,
            batch_first=True,
            dropout=0.2
        )
        self.fc = nn.Sequential(
            nn.Linear(hidden_dim, 32),
            nn.ReLU(),
            nn.Linear(32, 1),
            nn.Sigmoid()
        )

    def forward(self, x):
        lstm_out, _ = self.lstm(x)
        return self.fc(lstm_out[:, -1, :]).squeeze(-1)


class LSTML2Strategy:
    """
    LSTM L2策略 - 基于深度学习的中频交易

    原始收益: +2,618% (16个月, 1,340笔交易)
    核心逻辑来源: 纯累积LSTM_带缓存.py
    """

    def __init__(self, trading_system, config: LSTMConfig):
        self.system = trading_system
        self.config = config
        self._running = False
        self._model = None
        self._scaler = None
        self._state = PositionState.FLAT
        self._position = None
        self._feature_buffer = []
        self._log_callback = None
        self._device = 'cuda' if torch.cuda.is_available() else 'cpu'

    def load_model(self) -> bool:
        """
        加载LSTM模型和Scaler

        模型位置: C:\Repo\future-trading-strategy\experiments\model_cache_tick\
        """
        try:
            model_path = Path(self.config.model_path)
            scaler_path = Path(self.config.scaler_path)

            if not model_path.exists() or not scaler_path.exists():
                self._log("LSTM", "ERROR", f"模型文件不存在: {model_path}")
                return False

            # 加载Scaler
            with open(scaler_path, 'rb') as f:
                self._scaler = pickle.load(f)

            # 确定输入维度
            input_dim = self._scaler.n_features_in_

            # 加载模型
            self._model = LSTMModel(input_dim, self.config.hidden_dim)
            self._model.load_state_dict(torch.load(model_path, map_location=self._device))
            self._model.to(self._device)
            self._model.eval()

            self._log("LSTM", "INFO", f"模型加载成功, 输入维度={input_dim}")
            return True

        except Exception as e:
            self._log("LSTM", "ERROR", f"模型加载失败: {e}")
            return False

    def predict(self, features: np.ndarray) -> float:
        """
        LSTM预测

        输入: 特征序列 (seq_len, n_features)
        输出: 上涨概率 (0-1)
        """
        if self._model is None:
            return 0.5

        # 标准化
        features_scaled = self._scaler.transform(features)

        # 创建序列
        if len(features_scaled) < self.config.seq_len:
            return 0.5

        seq = features_scaled[-self.config.seq_len:]
        x = torch.FloatTensor(seq).unsqueeze(0).to(self._device)

        # 预测
        with torch.no_grad():
            prob = self._model(x).item()

        return prob

    def generate_signal(self, prob: float, rsi: float) -> int:
        """
        生成交易信号
        来源: 纯累积LSTM_带缓存.py generate_signals()

        规则:
        - prob > 0.5 且 RSI < 60 → 做多
        - prob < 0.5 且 RSI > 40 → 做空
        - 否则 → 无信号
        """
        if prob > self.config.signal_threshold and rsi < self.config.rsi_upper:
            return 1  # 做多
        elif prob < self.config.signal_threshold and rsi > self.config.rsi_lower:
            return -1  # 做空
        return 0  # 无信号

    def on_bar(self, bar_data: dict):
        """
        分钟Bar数据回调 - 策略主循环
        来源: 纯累积LSTM_带缓存.py run_state_machine_backtest()

        bar_data结构:
        {
            'datetime': datetime,
            'open': float,
            'high': float,
            'low': float,
            'close': float,
            'volume': int,
            'features': dict  # 93个特征
        }
        """
        if not self._running:
            return

        # 添加到特征缓冲
        features = bar_data.get('features', {})
        feature_array = np.array(list(features.values()))
        self._feature_buffer.append(feature_array)

        # 保持缓冲区大小
        if len(self._feature_buffer) > self.config.seq_len * 2:
            self._feature_buffer = self._feature_buffer[-self.config.seq_len * 2:]

        # 预测
        if len(self._feature_buffer) >= self.config.seq_len:
            feature_matrix = np.array(self._feature_buffer)
            prob = self.predict(feature_matrix)
        else:
            prob = 0.5

        rsi = features.get('rsi_14', 50)
        price = bar_data['close']

        # 状态机逻辑
        self._run_state_machine(price, prob, rsi, bar_data['datetime'])

    def _run_state_machine(self, price: float, prob: float, rsi: float, dt):
        """
        三态仓位状态机
        来源: 纯累积LSTM_带缓存.py

        状态转换:
        Flat -> Probe: 信号触发
        Probe -> Full: 盈利0.3%
        Probe -> Flat: 亏损0.3%
        Full -> Trail: 盈利0.5%
        Full -> Flat: 亏损0.4%
        Trail -> Flat: 回撤30% 或 盈利1.5%
        """

        if self._state == PositionState.FLAT:
            signal = self.generate_signal(prob, rsi)
            if signal != 0:
                self._open_probe(price, signal, dt)

        elif self._state == PositionState.PROBE:
            pnl_pct = self._calculate_pnl_pct(price)

            if pnl_pct >= self.config.probe_to_full:
                self._upgrade_to_full(price, dt)
            elif pnl_pct <= -self.config.probe_sl:
                self._close_position(price, "probe_sl", dt)

        elif self._state == PositionState.FULL:
            pnl_pct = self._calculate_pnl_pct(price)
            self._position['peak_pnl'] = max(
                self._position.get('peak_pnl', 0),
                pnl_pct
            )

            if pnl_pct >= self.config.full_to_trail:
                self._upgrade_to_trail(dt)
            elif pnl_pct <= -self.config.full_sl:
                self._close_position(price, "full_sl", dt)

        elif self._state == PositionState.TRAIL:
            pnl_pct = self._calculate_pnl_pct(price)
            self._position['peak_pnl'] = max(
                self._position.get('peak_pnl', 0),
                pnl_pct
            )
            peak = self._position['peak_pnl']

            drawdown = (peak - pnl_pct) / max(peak, 0.001) if peak > 0 else 0

            if drawdown >= self.config.trail_dd or pnl_pct >= self.config.trail_max:
                self._close_position(price, "trail_exit", dt)
            elif pnl_pct <= -self.config.full_sl:
                self._close_position(price, "trail_sl", dt)

    def _calculate_pnl_pct(self, current_price: float) -> float:
        """计算当前盈亏百分比"""
        if not self._position:
            return 0.0
        entry_price = self._position['entry_price']
        direction = self._position['direction']
        return direction * (current_price - entry_price) / entry_price

    def _open_probe(self, price: float, direction: int, dt):
        """开探针仓"""
        self._position = {
            'direction': direction,
            'entry_price': price,
            'entry_time': dt,
            'size': self.config.probe_size,
            'peak_pnl': 0
        }
        self._state = PositionState.PROBE

        direction_str = 'BUY' if direction == 1 else 'SELL'
        self._log("LSTM", "INFO", f"开探针仓: {direction_str} @ {price:.2f}")

        # CTP下单
        self.system.send_order(
            instrument_id=self.config.instrument_id,
            direction=direction_str,
            offset='OPEN',
            price=price,
            volume=int(self.config.probe_size)
        )

    def _upgrade_to_full(self, price: float, dt):
        """探针升满仓"""
        add_size = self.config.full_size - self.config.probe_size

        self._position['entry_price'] = price
        self._position['size'] = self.config.full_size
        self._position['peak_pnl'] = 0
        self._state = PositionState.FULL

        direction_str = 'BUY' if self._position['direction'] == 1 else 'SELL'
        self._log("LSTM", "INFO", f"升级满仓: {direction_str} +{add_size} @ {price:.2f}")

        # 加仓
        self.system.send_order(
            instrument_id=self.config.instrument_id,
            direction=direction_str,
            offset='OPEN',
            price=price,
            volume=int(add_size)
        )

    def _upgrade_to_trail(self, dt):
        """满仓转追踪"""
        self._state = PositionState.TRAIL
        self._log("LSTM", "INFO", f"启动追踪止盈, 当前盈利={self._position['peak_pnl']*100:.2f}%")

    def _close_position(self, price: float, reason: str, dt):
        """平仓"""
        pnl_pct = self._calculate_pnl_pct(price)
        cost = self.config.commission_rate * 2 + self.config.slippage * 2
        net_pnl = pnl_pct * self._position['size'] - cost

        self._log("LSTM", "INFO",
            f"平仓: {reason}, 净收益={net_pnl*100:.4f}%")

        # CTP平仓
        direction = self._position['direction']
        close_direction = 'SELL' if direction == 1 else 'BUY'

        self.system.send_order(
            instrument_id=self.config.instrument_id,
            direction=close_direction,
            offset='CLOSE',
            price=price,
            volume=int(self._position['size'])
        )

        self._position = None
        self._state = PositionState.FLAT

    def _log(self, source: str, level: str, message: str):
        if self._log_callback:
            self._log_callback(source, level, message)

    def start(self) -> bool:
        """启动策略"""
        if not self.load_model():
            return False
        self._running = True
        self._state = PositionState.FLAT
        self._feature_buffer = []
        return True

    def stop(self):
        """停止策略"""
        self._running = False

    def get_status(self) -> dict:
        return {
            'name': 'LSTM_L2',
            'running': self._running,
            'state': self._state.value,
            'position': self._position
        }
```

### 5.2 特征工程模块

```python
# ctp_trading_system/strategy/lstm_l2/feature_engine.py

import numpy as np
from collections import deque
from typing import Dict, List
from dataclasses import dataclass

@dataclass
class FeatureConfig:
    """特征工程配置"""
    lookback_5min: int = 5
    lookback_15min: int = 15
    lookback_30min: int = 30
    rsi_period: int = 14


class FeatureEngine:
    """
    特征工程引擎
    来源: feature_engineering.py + iceberg_detection.py + large_order_detection.py

    生成93个特征用于LSTM预测
    """

    def __init__(self, config: FeatureConfig = None):
        self.config = config or FeatureConfig()
        self._bar_buffer = deque(maxlen=60)  # 60分钟历史
        self._tick_buffer = deque(maxlen=1000)  # 1000个tick

    def calculate_features(self, bar_data: dict) -> Dict[str, float]:
        """
        计算完整特征集 (93个特征)

        特征分类:
        A. 基础OHLCV特征 (~30个)
        B. 订单流特征 (~15个)
        C. 冰山单特征 (~7个)
        D. 大单特征 (~6个)
        E. 技术指标 (~20个)
        F. 滞后特征 (~15个)
        """
        self._bar_buffer.append(bar_data)
        bars = list(self._bar_buffer)

        features = {}

        # A. 基础OHLCV
        features.update(self._calc_ohlcv_features(bars))

        # B. 订单流特征
        features.update(self._calc_orderflow_features(bars))

        # C. 冰山单特征 (需要tick数据)
        features.update(self._calc_iceberg_features())

        # D. 大单特征
        features.update(self._calc_large_order_features())

        # E. 技术指标
        features.update(self._calc_technical_indicators(bars))

        # F. 滞后特征
        features.update(self._calc_lag_features(bars))

        return features

    def _calc_ohlcv_features(self, bars: List[dict]) -> Dict[str, float]:
        """基础OHLCV特征"""
        features = {}

        if len(bars) < 2:
            return {f'return_{i}min': 0.0 for i in [1, 5, 15, 30]}

        closes = [b['close'] for b in bars]
        highs = [b['high'] for b in bars]
        lows = [b['low'] for b in bars]
        volumes = [b['volume'] for b in bars]

        # 收益率
        features['return_1min'] = (closes[-1] - closes[-2]) / closes[-2] if len(closes) >= 2 else 0
        features['return_5min'] = (closes[-1] - closes[-5]) / closes[-5] if len(closes) >= 5 else 0
        features['return_15min'] = (closes[-1] - closes[-15]) / closes[-15] if len(closes) >= 15 else 0
        features['return_30min'] = (closes[-1] - closes[-30]) / closes[-30] if len(closes) >= 30 else 0

        # 波动率
        if len(closes) >= 5:
            returns = np.diff(closes[-5:]) / np.array(closes[-5:-1])
            features['volatility_5min'] = np.std(returns) if len(returns) > 0 else 0
        else:
            features['volatility_5min'] = 0

        # 范围
        features['range_5min'] = (max(highs[-5:]) - min(lows[-5:])) / closes[-1] if len(bars) >= 5 else 0

        # 成交量
        features['volume_sum'] = sum(volumes[-5:]) if len(volumes) >= 5 else 0
        features['volume_ratio'] = volumes[-1] / np.mean(volumes[-20:]) if len(volumes) >= 20 else 1

        return features

    def _calc_orderflow_features(self, bars: List[dict]) -> Dict[str, float]:
        """订单流特征"""
        # 简化版本,实际需要tick级别数据
        return {
            'tick_imbalance': 0.0,
            'volume_imbalance': 0.0,
            'aggressive_buy_ratio': 0.5,
            'aggressive_sell_ratio': 0.5,
            'net_aggressive_ratio': 0.0
        }

    def _calc_iceberg_features(self) -> Dict[str, float]:
        """
        冰山单特征
        来源: iceberg_detection.py
        """
        return {
            'iceberg_imbalance': 0.0,
            'bid_iceberg_strength': 0.0,
            'ask_iceberg_strength': 0.0,
            'has_bid_iceberg': 0,
            'has_ask_iceberg': 0,
            'bid_iceberg_count': 0,
            'ask_iceberg_count': 0
        }

    def _calc_large_order_features(self) -> Dict[str, float]:
        """
        大单特征
        来源: large_order_detection.py
        """
        return {
            'large_order_ratio': 0.0,
            'large_order_imbalance': 0.0,
            'large_buy_count': 0,
            'large_sell_count': 0,
            'large_buy_volume': 0.0,
            'large_sell_volume': 0.0
        }

    def _calc_technical_indicators(self, bars: List[dict]) -> Dict[str, float]:
        """技术指标"""
        features = {}

        if len(bars) < 14:
            return {
                'rsi_14': 50.0,
                'ema_10': 0.0,
                'ema_30': 0.0,
                'momentum_5': 0.0
            }

        closes = np.array([b['close'] for b in bars])

        # RSI
        features['rsi_14'] = self._calc_rsi(closes, 14)

        # EMA
        features['ema_10'] = self._calc_ema(closes, 10)[-1]
        features['ema_30'] = self._calc_ema(closes, 30)[-1] if len(closes) >= 30 else closes[-1]

        # Momentum
        features['momentum_5'] = closes[-1] - closes[-5] if len(closes) >= 5 else 0

        return features

    def _calc_lag_features(self, bars: List[dict]) -> Dict[str, float]:
        """滞后特征"""
        features = {}

        if len(bars) < 4:
            return {f'return_lag{i}': 0.0 for i in range(1, 4)}

        closes = [b['close'] for b in bars]

        for i in range(1, 4):
            if len(closes) > i + 1:
                features[f'return_lag{i}'] = (closes[-i-1] - closes[-i-2]) / closes[-i-2]
            else:
                features[f'return_lag{i}'] = 0.0

        return features

    def _calc_rsi(self, prices: np.ndarray, period: int = 14) -> float:
        """计算RSI"""
        if len(prices) < period + 1:
            return 50.0

        deltas = np.diff(prices)
        gains = np.where(deltas > 0, deltas, 0)
        losses = np.where(deltas < 0, -deltas, 0)

        avg_gain = np.mean(gains[-period:])
        avg_loss = np.mean(losses[-period:])

        if avg_loss == 0:
            return 100.0

        rs = avg_gain / avg_loss
        return 100 - (100 / (1 + rs))

    def _calc_ema(self, prices: np.ndarray, period: int) -> np.ndarray:
        """计算EMA"""
        alpha = 2 / (period + 1)
        ema = np.zeros_like(prices)
        ema[0] = prices[0]
        for i in range(1, len(prices)):
            ema[i] = alpha * prices[i] + (1 - alpha) * ema[i-1]
        return ema

    def add_tick(self, tick_data: dict):
        """添加tick数据用于订单流分析"""
        self._tick_buffer.append(tick_data)
```

---

## 六、交易记录存储

### 6.1 数据模型 (整合两个策略的TradeDetail)

```python
# ctp_trading_system/storage/models.py

from dataclasses import dataclass, field, asdict
from typing import Optional, Dict, Any
from datetime import datetime
from enum import Enum

class TradeDirection(Enum):
    LONG = 1
    SHORT = -1

class ExitReason(Enum):
    STOP_LOSS = "stop_loss"
    TAKE_PROFIT = "take_profit"
    TRAIL_STOP = "trail_stop"
    IMB_REVERSAL = "imb_reversal"
    TIMEOUT = "timeout"
    MANUAL = "manual"
    PROBE_SL = "probe_sl"
    FULL_SL = "full_sl"
    TRAIL_EXIT = "trail_exit"

@dataclass
class TradeRecord:
    """
    统一交易记录模型
    整合自:
    - L2滑点回测.py TradeDetail (80+字段)
    - tick_timeframe_test.py TickTradeDetail
    """

    # ========== A. 定位与标识 ==========
    id: Optional[int] = None              # 数据库主键
    trade_id: int = 0                     # 策略内序号
    global_id: str = ""                   # 全局唯一ID
    strategy_name: str = ""               # 策略名: H1e_TICK / LSTM_L2
    config_name: str = ""                 # 配置名称
    symbol: str = ""                      # 合约代码
    run_id: str = ""                      # 运行批次ID

    # ========== B. 时间字段 ==========
    signal_datetime: Optional[datetime] = None  # 信号时间
    entry_datetime: Optional[datetime] = None   # 入场时间
    exit_datetime: Optional[datetime] = None    # 出场时间
    signal_timestamp_ms: int = 0          # 信号毫秒时间戳
    entry_timestamp_ms: int = 0           # 入场毫秒时间戳
    exit_timestamp_ms: int = 0            # 出场毫秒时间戳

    # ========== C. 方向与仓位 ==========
    direction: int = 0                    # 1=多, -1=空
    volume: int = 1                       # 手数
    position_state: str = ""              # 仓位状态: probe/full/trail
    hold_duration_seconds: float = 0      # 持仓时长(秒)
    hold_bars: int = 0                    # 持仓bar数 (LSTM)
    hold_ticks: int = 0                   # 持仓tick数 (H1e)

    # ========== D. 价格与执行 ==========
    signal_price: float = 0.0             # 信号价格
    entry_price: float = 0.0              # 成交价格
    exit_price: float = 0.0               # 平仓价格
    highest_price: float = 0.0            # 持仓期最高价
    lowest_price: float = 0.0             # 持仓期最低价

    # ========== E. 信号质量 (策略特有) ==========
    entry_imb: float = 0.0                # H1e: IMB值
    entry_prob: float = 0.5               # LSTM: 预测概率
    signal_strength: str = ""             # 信号强度: weak/medium/strong
    entry_depth: int = 0                  # 盘口深度
    entry_volatility: float = 0.0         # 入场波动率
    entry_rsi: float = 50.0               # RSI值

    # ========== F. 收益与成本 ==========
    pnl_ticks: float = 0.0                # 盈亏跳数
    gross_pnl_pct: float = 0.0            # 毛收益%
    net_pnl_pct: float = 0.0              # 净收益%
    commission: float = 0.0               # 手续费
    slippage_pct: float = 0.0             # 滑点%
    total_cost_pct: float = 0.0           # 总成本%

    # ========== G. MAE/MFE ==========
    mae_pct: float = 0.0                  # 最大不利偏移%
    mfe_pct: float = 0.0                  # 最大有利偏移%
    r_multiple: float = 0.0               # R倍数

    # ========== H. 退出状态 ==========
    exit_reason: str = ""                 # 退出原因
    final_state: str = ""                 # completed/cancelled/error

    # ========== I. CTP订单关联 ==========
    entry_order_ref: str = ""             # 入场报单引用
    exit_order_ref: str = ""              # 平仓报单引用
    entry_order_sys_id: str = ""          # 交易所入场单号
    exit_order_sys_id: str = ""           # 交易所平仓单号

    # ========== J. 扩展数据 (JSON) ==========
    l2_snapshot_entry: Optional[Dict] = None   # 入场L2盘口快照
    l2_snapshot_exit: Optional[Dict] = None    # 出场L2盘口快照
    extra_data: Optional[Dict] = None          # 其他扩展数据

    # ========== K. 元数据 ==========
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None

    def to_dict(self) -> Dict[str, Any]:
        """转换为字典"""
        return asdict(self)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'TradeRecord':
        """从字典创建"""
        return cls(**{k: v for k, v in data.items() if k in cls.__dataclass_fields__})
```

### 6.2 数据库管理

```python
# ctp_trading_system/storage/database.py

import sqlite3
import json
from pathlib import Path
from datetime import datetime
from typing import List, Optional
from contextlib import contextmanager

from .models import TradeRecord

class TradeDatabase:
    """交易记录数据库管理"""

    def __init__(self, db_path: str = None):
        if db_path is None:
            db_path = Path(__file__).parent.parent / "data" / "trades.db"
        self.db_path = Path(db_path)
        self.db_path.parent.mkdir(parents=True, exist_ok=True)
        self._init_db()

    def _init_db(self):
        """初始化数据库表"""
        with self._get_connection() as conn:
            conn.execute('''
                CREATE TABLE IF NOT EXISTS trades (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    trade_id INTEGER,
                    global_id TEXT UNIQUE,
                    strategy_name TEXT,
                    config_name TEXT,
                    symbol TEXT,
                    run_id TEXT,

                    signal_datetime TEXT,
                    entry_datetime TEXT,
                    exit_datetime TEXT,
                    signal_timestamp_ms INTEGER,
                    entry_timestamp_ms INTEGER,
                    exit_timestamp_ms INTEGER,

                    direction INTEGER,
                    volume INTEGER,
                    position_state TEXT,
                    hold_duration_seconds REAL,
                    hold_bars INTEGER,
                    hold_ticks INTEGER,

                    signal_price REAL,
                    entry_price REAL,
                    exit_price REAL,
                    highest_price REAL,
                    lowest_price REAL,

                    entry_imb REAL,
                    entry_prob REAL,
                    signal_strength TEXT,
                    entry_depth INTEGER,
                    entry_volatility REAL,
                    entry_rsi REAL,

                    pnl_ticks REAL,
                    gross_pnl_pct REAL,
                    net_pnl_pct REAL,
                    commission REAL,
                    slippage_pct REAL,
                    total_cost_pct REAL,

                    mae_pct REAL,
                    mfe_pct REAL,
                    r_multiple REAL,

                    exit_reason TEXT,
                    final_state TEXT,

                    entry_order_ref TEXT,
                    exit_order_ref TEXT,
                    entry_order_sys_id TEXT,
                    exit_order_sys_id TEXT,

                    l2_snapshot_entry TEXT,
                    l2_snapshot_exit TEXT,
                    extra_data TEXT,

                    created_at TEXT DEFAULT CURRENT_TIMESTAMP,
                    updated_at TEXT DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # 索引
            conn.execute('CREATE INDEX IF NOT EXISTS idx_strategy ON trades(strategy_name)')
            conn.execute('CREATE INDEX IF NOT EXISTS idx_symbol ON trades(symbol)')
            conn.execute('CREATE INDEX IF NOT EXISTS idx_entry_datetime ON trades(entry_datetime)')
            conn.execute('CREATE INDEX IF NOT EXISTS idx_run_id ON trades(run_id)')

            conn.commit()

    @contextmanager
    def _get_connection(self):
        """获取数据库连接"""
        conn = sqlite3.connect(str(self.db_path))
        conn.row_factory = sqlite3.Row
        try:
            yield conn
        finally:
            conn.close()

    def insert_trade(self, trade: TradeRecord) -> int:
        """插入交易记录"""
        data = trade.to_dict()

        # JSON序列化
        for key in ['l2_snapshot_entry', 'l2_snapshot_exit', 'extra_data']:
            if data.get(key):
                data[key] = json.dumps(data[key])

        # 时间格式化
        for key in ['signal_datetime', 'entry_datetime', 'exit_datetime']:
            if data.get(key) and isinstance(data[key], datetime):
                data[key] = data[key].isoformat()

        columns = [k for k in data.keys() if k != 'id']
        placeholders = ', '.join(['?' for _ in columns])
        column_names = ', '.join(columns)

        with self._get_connection() as conn:
            cursor = conn.execute(
                f'INSERT INTO trades ({column_names}) VALUES ({placeholders})',
                [data[k] for k in columns]
            )
            conn.commit()
            return cursor.lastrowid

    def get_trades_by_strategy(self, strategy_name: str,
                                start_date: str = None,
                                end_date: str = None) -> List[TradeRecord]:
        """按策略查询交易记录"""
        query = 'SELECT * FROM trades WHERE strategy_name = ?'
        params = [strategy_name]

        if start_date:
            query += ' AND entry_datetime >= ?'
            params.append(start_date)
        if end_date:
            query += ' AND entry_datetime <= ?'
            params.append(end_date)

        query += ' ORDER BY entry_datetime'

        with self._get_connection() as conn:
            rows = conn.execute(query, params).fetchall()
            return [self._row_to_trade(row) for row in rows]

    def get_daily_summary(self, date: str, strategy_name: str = None) -> dict:
        """获取日统计"""
        query = '''
            SELECT
                COUNT(*) as total_trades,
                SUM(CASE WHEN net_pnl_pct > 0 THEN 1 ELSE 0 END) as winning_trades,
                SUM(net_pnl_pct) as total_pnl_pct,
                AVG(net_pnl_pct) as avg_pnl_pct,
                MIN(net_pnl_pct) as min_pnl_pct,
                MAX(net_pnl_pct) as max_pnl_pct
            FROM trades
            WHERE date(entry_datetime) = ?
        '''
        params = [date]

        if strategy_name:
            query += ' AND strategy_name = ?'
            params.append(strategy_name)

        with self._get_connection() as conn:
            row = conn.execute(query, params).fetchone()
            return dict(row) if row else {}

    def export_to_csv(self, output_path: str, strategy_name: str = None):
        """导出CSV"""
        import csv

        query = 'SELECT * FROM trades'
        params = []
        if strategy_name:
            query += ' WHERE strategy_name = ?'
            params.append(strategy_name)
        query += ' ORDER BY entry_datetime'

        with self._get_connection() as conn:
            rows = conn.execute(query, params).fetchall()

            if not rows:
                return

            with open(output_path, 'w', newline='', encoding='utf-8') as f:
                writer = csv.writer(f)
                writer.writerow(rows[0].keys())
                for row in rows:
                    writer.writerow(row)

    def _row_to_trade(self, row: sqlite3.Row) -> TradeRecord:
        """将数据库行转换为TradeRecord"""
        data = dict(row)

        # JSON反序列化
        for key in ['l2_snapshot_entry', 'l2_snapshot_exit', 'extra_data']:
            if data.get(key):
                data[key] = json.loads(data[key])

        return TradeRecord.from_dict(data)
```

---

## 七、策略管理器

```python
# ctp_trading_system/strategy/strategy_manager.py

from typing import Dict, Optional, List
from enum import Enum
from dataclasses import dataclass

from .base_strategy import BaseStrategy
from .h1e_tick.h1e_strategy import H1eTickStrategy, H1eConfig
from .lstm_l2.lstm_strategy import LSTML2Strategy, LSTMConfig


class StrategyType(Enum):
    H1E_TICK = "H1e_TICK"
    LSTM_L2 = "LSTM_L2"
    DEMO_AUTO = "DEMO_AUTO"


@dataclass
class StrategyAllocation:
    """仓位分配"""
    strategy_type: StrategyType
    allocation_pct: float  # 仓位占比 (0-1)
    max_position: int      # 最大持仓手数


class StrategyManager:
    """
    策略管理器

    功能:
    1. 策略注册与管理
    2. 手动切换策略
    3. 同时运行多策略
    4. 仓位分配控制
    """

    def __init__(self, trading_system):
        self.system = trading_system
        self._strategies: Dict[str, BaseStrategy] = {}
        self._allocations: Dict[str, StrategyAllocation] = {}
        self._active_strategies: List[str] = []

    def register_strategy(self,
                          strategy_type: StrategyType,
                          config: dict,
                          allocation: StrategyAllocation = None):
        """注册策略"""
        name = strategy_type.value

        if strategy_type == StrategyType.H1E_TICK:
            h1e_config = H1eConfig(**config)
            self._strategies[name] = H1eTickStrategy(self.system, h1e_config)

        elif strategy_type == StrategyType.LSTM_L2:
            lstm_config = LSTMConfig(**config)
            self._strategies[name] = LSTML2Strategy(self.system, lstm_config)

        if allocation:
            self._allocations[name] = allocation

    def start_strategy(self, name: str) -> bool:
        """启动指定策略"""
        if name not in self._strategies:
            return False

        strategy = self._strategies[name]
        success = strategy.start()

        if success and name not in self._active_strategies:
            self._active_strategies.append(name)

        return success

    def stop_strategy(self, name: str) -> bool:
        """停止指定策略"""
        if name not in self._strategies:
            return False

        strategy = self._strategies[name]
        strategy.stop()

        if name in self._active_strategies:
            self._active_strategies.remove(name)

        return True

    def switch_strategy(self, from_name: str, to_name: str) -> bool:
        """
        切换策略 (手动)

        1. 停止当前策略
        2. 等待平仓完成
        3. 启动新策略
        """
        if from_name in self._active_strategies:
            self.stop_strategy(from_name)

        return self.start_strategy(to_name)

    def set_allocation(self, name: str, allocation_pct: float, max_position: int):
        """设置仓位分配"""
        if name in self._strategies:
            self._allocations[name] = StrategyAllocation(
                strategy_type=StrategyType(name),
                allocation_pct=allocation_pct,
                max_position=max_position
            )

    def get_active_strategies(self) -> List[str]:
        """获取运行中的策略列表"""
        return self._active_strategies.copy()

    def get_all_status(self) -> Dict[str, dict]:
        """获取所有策略状态"""
        status = {}
        for name, strategy in self._strategies.items():
            status[name] = {
                **strategy.get_status(),
                'active': name in self._active_strategies,
                'allocation': self._allocations.get(name)
            }
        return status

    def on_tick(self, tick_data: dict):
        """Tick数据分发给活跃策略"""
        for name in self._active_strategies:
            strategy = self._strategies.get(name)
            if strategy and hasattr(strategy, 'on_tick'):
                strategy.on_tick(tick_data)

    def on_bar(self, bar_data: dict):
        """Bar数据分发给活跃策略"""
        for name in self._active_strategies:
            strategy = self._strategies.get(name)
            if strategy and hasattr(strategy, 'on_bar'):
                strategy.on_bar(bar_data)
```

---

## 八、风控引擎

```python
# ctp_trading_system/risk/risk_engine.py

from dataclasses import dataclass
from datetime import datetime, time
from typing import List, Tuple, Optional

@dataclass
class RiskConfig:
    """风控配置"""
    # 日内风控
    daily_stop_loss_pct: float = -0.007    # 日亏-0.7%停止
    max_daily_trades: int = 500
    max_consecutive_losses: int = 10

    # 单笔风控
    max_single_loss_pct: float = -0.005    # 单笔最大亏损-0.5%
    max_position_value: float = 100000     # 最大持仓金额

    # 交易时段
    trading_sessions: List[Tuple[time, time]] = None
    enable_night_session: bool = True

    def __post_init__(self):
        if self.trading_sessions is None:
            self.trading_sessions = [
                (time(9, 0), time(10, 15)),
                (time(10, 30), time(11, 30)),
                (time(13, 30), time(15, 0)),
                (time(21, 0), time(23, 0)),
            ]


class RiskEngine:
    """
    风控引擎
    来源: production_config.py
    """

    def __init__(self, config: RiskConfig = None):
        self.config = config or RiskConfig()
        self._daily_pnl = 0.0
        self._daily_trades = 0
        self._consecutive_losses = 0
        self._last_trade_date = None
        self._trading_paused = False

    def reset_daily(self):
        """每日重置"""
        self._daily_pnl = 0.0
        self._daily_trades = 0
        self._consecutive_losses = 0
        self._trading_paused = False

    def check_trade_allowed(self) -> Tuple[bool, str]:
        """检查是否允许交易"""
        now = datetime.now()

        # 检查日期变化
        if self._last_trade_date != now.date():
            self.reset_daily()
            self._last_trade_date = now.date()

        # 检查交易时段
        if not self._is_trading_time(now.time()):
            return False, "非交易时段"

        # 检查是否暂停
        if self._trading_paused:
            return False, "交易已暂停"

        # 检查日亏损
        if self._daily_pnl <= self.config.daily_stop_loss_pct:
            self._trading_paused = True
            return False, f"日亏损达到{self._daily_pnl*100:.2f}%"

        # 检查日交易数
        if self._daily_trades >= self.config.max_daily_trades:
            return False, f"日交易数达到{self._daily_trades}"

        # 检查连续亏损
        if self._consecutive_losses >= self.config.max_consecutive_losses:
            return False, f"连续亏损{self._consecutive_losses}次"

        return True, "OK"

    def record_trade(self, pnl_pct: float):
        """记录交易结果"""
        self._daily_pnl += pnl_pct
        self._daily_trades += 1

        if pnl_pct < 0:
            self._consecutive_losses += 1
        else:
            self._consecutive_losses = 0

    def _is_trading_time(self, t: time) -> bool:
        """检查是否在交易时段"""
        for start, end in self.config.trading_sessions:
            if start <= t <= end:
                return True
        return False

    def get_status(self) -> dict:
        """获取风控状态"""
        return {
            'daily_pnl': self._daily_pnl,
            'daily_trades': self._daily_trades,
            'consecutive_losses': self._consecutive_losses,
            'trading_paused': self._trading_paused
        }
```

---

## 九、API扩展

```python
# ctp_trading_system/web/api/strategy.py (扩展)

from fastapi import APIRouter
from pydantic import BaseModel
from typing import Optional, Dict, List

router = APIRouter()

class StrategyStartRequest(BaseModel):
    """启动策略请求"""
    strategy_name: str  # H1e_TICK / LSTM_L2
    config: Optional[Dict] = None
    allocation_pct: float = 1.0
    max_position: int = 1

class AllocationRequest(BaseModel):
    """仓位分配请求"""
    allocations: Dict[str, float]  # {策略名: 占比}

@router.post("/start/{strategy_name}")
async def start_strategy(strategy_name: str, request: StrategyStartRequest):
    """启动指定策略"""
    manager = get_strategy_manager()
    success = manager.start_strategy(strategy_name)
    return {"success": success, "message": f"策略 {strategy_name} 启动" if success else "启动失败"}

@router.post("/stop/{strategy_name}")
async def stop_strategy(strategy_name: str):
    """停止指定策略"""
    manager = get_strategy_manager()
    success = manager.stop_strategy(strategy_name)
    return {"success": success}

@router.post("/switch")
async def switch_strategy(from_name: str, to_name: str):
    """切换策略"""
    manager = get_strategy_manager()
    success = manager.switch_strategy(from_name, to_name)
    return {"success": success}

@router.post("/allocation")
async def set_allocation(request: AllocationRequest):
    """设置仓位分配"""
    manager = get_strategy_manager()
    for name, pct in request.allocations.items():
        manager.set_allocation(name, pct, max_position=int(pct * 10))
    return {"success": True}

@router.get("/status")
async def get_all_status():
    """获取所有策略状态"""
    manager = get_strategy_manager()
    return {"data": manager.get_all_status()}

@router.get("/active")
async def get_active_strategies():
    """获取运行中策略列表"""
    manager = get_strategy_manager()
    return {"data": manager.get_active_strategies()}
```

---

## 十、实盘数据缓存与备份设计

### 10.1 双流数据架构

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         双流数据架构                                     │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  【实时流】用于信号计算              【备份流】用于复盘回测              │
│                                                                         │
│  CTP行情 (Tick/Bar)                                                     │
│      │                                                                  │
│      ├──→ TickCache (120 ticks, 60秒滚动窗口)                          │
│      │         │                                                        │
│      │         ▼                                                        │
│      │    特征提取 (68个特征)                                           │
│      │         │                                                        │
│      │         ▼                                                        │
│      │    策略推理 (H1e IMB / LSTM预测)                                 │
│      │         │                                                        │
│      │         ▼                                                        │
│      │    信号生成 → 交易执行                                           │
│      │                   │                                              │
│      │                   ▼                                              │
│      └────────────→ TradeContext ──→ ContextManager                    │
│                      (完整上下文)     (异步非阻塞保存)                   │
│                           │                                             │
│                           ▼                                             │
│                    ctp_trading_system/data_backup/                      │
│                    └── {symbol}/{date}/                                 │
│                        ├── ctx_{trade_id}.pkl  (完整数据)               │
│                        └── ctx_{trade_id}.json (可读摘要)               │
└─────────────────────────────────────────────────────────────────────────┘
```

### 10.2 目录结构

```
ctp_trading_system/
├── data/                         # [新增] 数据管理模块
│   ├── __init__.py
│   ├── tick_cache.py            # 实时Tick缓存
│   ├── bar_aggregator.py        # Bar聚合器
│   ├── trade_context.py         # 交易上下文定义
│   └── context_manager.py       # 异步保存管理器
│
└── data_backup/                  # [新增] 备份数据目录
    ├── rb/                       # 按品种分类
    │   ├── 2026-01-27/          # 按日期分类
    │   │   ├── ctx_001.pkl
    │   │   ├── ctx_001.json
    │   │   └── ...
    │   └── 2026-01-28/
    └── au/
```

### 10.3 缓存组件总览

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         缓存组件架构                                     │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  CTP Tick数据                                                           │
│      │                                                                  │
│      ├──→ TickCache (120 ticks)                                        │
│      │         │                                                        │
│      │         ├──→ IMB计算 (H1e策略)                                   │
│      │         │                                                        │
│      │         └──→ BarAggregator ──→ BarBuffer (60 bars)              │
│      │                                    │                             │
│      │                                    └──→ FeatureEngine            │
│      │                                              │                   │
│      │                                              ▼                   │
│      │                                    FeatureSequenceCache [10,68]  │
│      │                                              │                   │
│      │                                              ▼                   │
│      │                                         LSTM推理                 │
│      │                                                                  │
│      └──→ L2DepthBuffer (5档深度)                                       │
│                │                                                        │
│                └──→ 冰山单/大单检测                                      │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

| 缓存组件 | 容量 | 内存占用 | 用途 |
|---------|------|---------|------|
| TickCache | 120 ticks | ~12 KB | IMB计算、波动率 |
| BarAggregator | 实时聚合 | ~1 KB | tick→bar |
| BarBuffer | 60 bars | ~6 KB | 特征计算历史 |
| FeatureSequenceCache | [10, 68] | ~3 KB | LSTM输入 |
| L2DepthBuffer | 最新5档 | ~0.5 KB | 冰山单检测 |
| ModelCache | 1个模型 | ~50 MB | LSTM推理 |

**总内存占用: < 100 MB**

---

### 10.4 TickCache - 实时数据缓存

```python
# ctp_trading_system/data/tick_cache.py

from collections import deque
from dataclasses import dataclass
from typing import Dict, List, Optional
import numpy as np

@dataclass
class TickData:
    """CTP Tick数据结构"""
    datetime: str
    last_price: float
    bid_price1: float
    bid_volume1: int
    ask_price1: float
    ask_volume1: int
    volume: int
    open_interest: float


class TickCache:
    """
    实时Tick缓存
    来源: C:\Repo\future-trading-strategy\docs\代码深度审查与改进建议.md

    功能:
    - 缓存最近120个tick (约60秒，每500ms一个)
    - 自动滚动窗口 (deque实现)
    - 提取68个聚合特征
    """

    def __init__(self, maxlen: int = 120):
        self.maxlen = maxlen
        self._buffer: deque = deque(maxlen=maxlen)
        self._price_buffer: deque = deque(maxlen=maxlen)

    def add_tick(self, tick: TickData):
        """添加tick到缓存"""
        self._buffer.append(tick)
        self._price_buffer.append(tick.last_price)

    def is_ready(self) -> bool:
        """缓存是否已满"""
        return len(self._buffer) >= self.maxlen

    def get_ticks(self) -> List[TickData]:
        """获取所有缓存的tick"""
        return list(self._buffer)

    def extract_features(self) -> Dict[str, float]:
        """
        提取68个聚合特征

        特征分类:
        - 价格特征 (13个): OHLC, range, mean, std等
        - 成交量特征 (8个): sum, mean, std, VWAP等
        - L2深度特征 (25个): OBI, 盘口压力, 流动性等
        - 订单流特征 (10个): 买卖比, 净成交量等
        - 时间序列特征 (12个): 自相关, tick计数等
        """
        if not self.is_ready():
            return {}

        ticks = list(self._buffer)
        prices = [t.last_price for t in ticks]
        volumes = [t.volume for t in ticks]
        bid_vols = [t.bid_volume1 for t in ticks]
        ask_vols = [t.ask_volume1 for t in ticks]

        features = {}

        # 价格特征
        features['price_open'] = prices[0]
        features['price_high'] = max(prices)
        features['price_low'] = min(prices)
        features['price_close'] = prices[-1]
        features['price_mean'] = np.mean(prices)
        features['price_std'] = np.std(prices)
        features['price_range'] = max(prices) - min(prices)

        # 成交量特征
        vol_diffs = np.diff(volumes)
        features['volume_sum'] = sum(vol_diffs) if len(vol_diffs) > 0 else 0
        features['volume_mean'] = np.mean(vol_diffs) if len(vol_diffs) > 0 else 0

        # L2深度特征 - IMB
        total_bid = sum(bid_vols)
        total_ask = sum(ask_vols)
        features['imb_mean'] = (total_bid - total_ask) / (total_bid + total_ask + 1)
        features['depth_total'] = total_bid + total_ask

        # 波动率
        returns = np.diff(prices) / np.array(prices[:-1])
        features['volatility'] = np.std(returns) if len(returns) > 0 else 0

        return features

    def clear(self):
        """清空缓存"""
        self._buffer.clear()
        self._price_buffer.clear()
```

### 10.5 BarAggregator - Bar聚合器

```python
# ctp_trading_system/data/bar_aggregator.py

from collections import deque
from dataclasses import dataclass, field
from typing import Optional, Callable, List
from datetime import datetime

@dataclass
class BarData:
    """K线数据结构"""
    datetime: str
    open: float = 0.0
    high: float = 0.0
    low: float = 0.0
    close: float = 0.0
    volume: int = 0
    open_interest: float = 0.0


class BarAggregator:
    """
    Tick到Bar实时聚合器
    来源: C:\Repo\future-trading-strategy\live\bar_aggregator.py

    功能:
    - tick级别实时聚合成1分钟Bar
    - 每分钟自动切换新Bar
    - 支持回调通知完成的Bar
    """

    def __init__(self, on_bar_completed: Optional[Callable] = None):
        self._current_bar: Optional[BarData] = None
        self._current_minute: Optional[int] = None
        self._on_bar_completed = on_bar_completed

    def on_tick(self, tick_data: dict) -> Optional[BarData]:
        """
        处理tick数据

        Args:
            tick_data: CTP tick数据

        Returns:
            如果一根Bar完成,返回该Bar,否则None
        """
        price = tick_data.get('last_price', 0)
        volume = tick_data.get('volume', 0)
        timestamp = tick_data.get('datetime', datetime.now().isoformat())

        # 解析分钟
        try:
            dt = datetime.fromisoformat(timestamp)
            current_minute = dt.minute
        except:
            current_minute = datetime.now().minute

        completed_bar = None

        # 新分钟开始 - 完成旧Bar,开始新Bar
        if self._current_minute is not None and current_minute != self._current_minute:
            completed_bar = self._current_bar
            self._current_bar = None

            # 通知完成
            if completed_bar and self._on_bar_completed:
                self._on_bar_completed(completed_bar)

        # 更新当前Bar
        if self._current_bar is None:
            self._current_bar = BarData(
                datetime=timestamp,
                open=price,
                high=price,
                low=price,
                close=price,
                volume=0
            )
        else:
            self._current_bar.high = max(self._current_bar.high, price)
            self._current_bar.low = min(self._current_bar.low, price)
            self._current_bar.close = price
            self._current_bar.volume = volume - (self._last_volume or volume)

        self._current_minute = current_minute
        self._last_volume = volume

        return completed_bar

    def get_current_bar(self) -> Optional[BarData]:
        """获取当前未完成的Bar"""
        return self._current_bar


class BarBuffer:
    """
    Bar数据缓存
    保存最近60根Bar用于特征计算
    """

    def __init__(self, maxlen: int = 60):
        self._buffer: deque = deque(maxlen=maxlen)

    def add_bar(self, bar: BarData):
        """添加Bar"""
        self._buffer.append(bar)

    def get_bars(self) -> List[BarData]:
        """获取所有Bar"""
        return list(self._buffer)

    def is_ready(self, min_bars: int = 10) -> bool:
        """是否有足够的Bar"""
        return len(self._buffer) >= min_bars

    def get_close_series(self) -> List[float]:
        """获取收盘价序列"""
        return [b.close for b in self._buffer]
```

### 10.6 L2DepthBuffer - L2盘口缓存

```python
# ctp_trading_system/data/l2_depth_buffer.py

from dataclasses import dataclass, field
from typing import List, Optional
import numpy as np

@dataclass
class L2Depth:
    """L2深度数据 (5档)"""
    bid_prices: List[float] = field(default_factory=list)
    bid_volumes: List[int] = field(default_factory=list)
    ask_prices: List[float] = field(default_factory=list)
    ask_volumes: List[int] = field(default_factory=list)
    timestamp_ms: int = 0


class L2DepthBuffer:
    """
    L2深度缓存
    来源: C:\Repo\future-trading-strategy\iceberg_detection.py

    功能:
    - 缓存最新5档盘口数据
    - 计算订单簿不平衡 (OBI)
    - 检测冰山单/大单
    """

    def __init__(self):
        self._current_depth: Optional[L2Depth] = None
        self._depth_history: List[L2Depth] = []
        self._max_history = 100  # 保留最近100个快照

    def update(self, depth: L2Depth):
        """更新最新盘口"""
        self._current_depth = depth
        self._depth_history.append(depth)
        if len(self._depth_history) > self._max_history:
            self._depth_history.pop(0)

    def update_from_tick(self, tick_data: dict):
        """从tick数据更新 (CTP仅提供1档)"""
        depth = L2Depth(
            bid_prices=[tick_data.get('bid_price1', 0)],
            bid_volumes=[tick_data.get('bid_volume1', 0)],
            ask_prices=[tick_data.get('ask_price1', 0)],
            ask_volumes=[tick_data.get('ask_volume1', 0)],
            timestamp_ms=int(tick_data.get('timestamp', 0) * 1000)
        )
        self.update(depth)

    def get_obi(self) -> float:
        """
        计算订单簿不平衡 (Order Book Imbalance)
        OBI = (bid_vol - ask_vol) / (bid_vol + ask_vol)
        """
        if not self._current_depth:
            return 0.0

        bid_vol = sum(self._current_depth.bid_volumes)
        ask_vol = sum(self._current_depth.ask_volumes)

        if bid_vol + ask_vol == 0:
            return 0.0

        return (bid_vol - ask_vol) / (bid_vol + ask_vol)

    def detect_iceberg(self) -> dict:
        """
        检测冰山单
        来源: iceberg_detection.py

        检测逻辑:
        - 盘口显示量小,但连续成交量大
        - 多次相同价位的小单挂单
        """
        if len(self._depth_history) < 10:
            return {
                'has_bid_iceberg': False,
                'has_ask_iceberg': False,
                'bid_iceberg_strength': 0.0,
                'ask_iceberg_strength': 0.0
            }

        # 简化版检测: 检测盘口量与历史均值的比例
        recent_depths = self._depth_history[-10:]

        bid_vols = [sum(d.bid_volumes) for d in recent_depths]
        ask_vols = [sum(d.ask_volumes) for d in recent_depths]

        bid_std = np.std(bid_vols) if len(bid_vols) > 1 else 0
        ask_std = np.std(ask_vols) if len(ask_vols) > 1 else 0

        # 波动大可能有冰山单
        return {
            'has_bid_iceberg': bid_std > np.mean(bid_vols) * 0.5 if bid_vols else False,
            'has_ask_iceberg': ask_std > np.mean(ask_vols) * 0.5 if ask_vols else False,
            'bid_iceberg_strength': bid_std / (np.mean(bid_vols) + 1),
            'ask_iceberg_strength': ask_std / (np.mean(ask_vols) + 1)
        }

    def get_snapshot(self) -> Optional[L2Depth]:
        """获取当前快照"""
        return self._current_depth
```

### 10.7 FeatureSequenceCache - 特征序列缓存

```python
# ctp_trading_system/data/feature_sequence_cache.py

from collections import deque
from typing import List, Dict, Optional
import numpy as np

class FeatureSequenceCache:
    """
    特征序列缓存
    来源: C:\Repo\future-trading-strategy\策略代码\LSTM_L2滑点回测.py

    功能:
    - 缓存最近10个时间步的68个特征
    - 形成[10, 68]的特征矩阵用于LSTM输入
    - 支持特征标准化
    """

    def __init__(self, sequence_length: int = 10, feature_dim: int = 68):
        self.sequence_length = sequence_length
        self.feature_dim = feature_dim
        self._buffer: deque = deque(maxlen=sequence_length)
        self._scaler = None  # 标准化器

    def set_scaler(self, scaler):
        """设置标准化器 (从模型加载)"""
        self._scaler = scaler

    def add_features(self, features: Dict[str, float]):
        """
        添加一个时间步的特征

        Args:
            features: 特征字典 {feature_name: value}
        """
        # 转换为固定顺序的数组
        feature_names = sorted(features.keys())[:self.feature_dim]
        feature_array = np.array([features.get(name, 0.0) for name in feature_names])

        # 补齐到feature_dim维
        if len(feature_array) < self.feature_dim:
            feature_array = np.pad(feature_array, (0, self.feature_dim - len(feature_array)))

        self._buffer.append(feature_array)

    def is_ready(self) -> bool:
        """是否有足够的序列长度"""
        return len(self._buffer) >= self.sequence_length

    def get_matrix(self) -> np.ndarray:
        """
        获取特征矩阵 [sequence_length, feature_dim]

        Returns:
            原始特征矩阵
        """
        if not self.is_ready():
            return np.zeros((self.sequence_length, self.feature_dim))

        return np.array(list(self._buffer))

    def get_scaled_matrix(self) -> np.ndarray:
        """
        获取标准化后的特征矩阵

        Returns:
            标准化后的[sequence_length, feature_dim]矩阵
        """
        matrix = self.get_matrix()

        if self._scaler is not None:
            # 展平 -> 标准化 -> 重塑
            flat = matrix.reshape(1, -1)
            scaled_flat = self._scaler.transform(flat)
            return scaled_flat.reshape(self.sequence_length, self.feature_dim)

        return matrix

    def get_lstm_input(self) -> np.ndarray:
        """
        获取LSTM输入张量 [1, sequence_length, feature_dim]

        Returns:
            可直接输入LSTM的张量
        """
        matrix = self.get_scaled_matrix()
        return matrix.reshape(1, self.sequence_length, self.feature_dim)

    def clear(self):
        """清空缓存"""
        self._buffer.clear()
```

### 10.8 TradeContext - 交易上下文

```python
# ctp_trading_system/data/trade_context.py

from dataclasses import dataclass, field, asdict
from typing import Optional, Dict, List, Any
from datetime import datetime
import hashlib
import json

@dataclass
class L1Snapshot:
    """L1行情快照"""
    last_price: float = 0.0
    bid_price1: float = 0.0
    bid_volume1: int = 0
    ask_price1: float = 0.0
    ask_volume1: int = 0
    volume: int = 0
    timestamp_ms: int = 0

@dataclass
class L2Snapshot:
    """L2深度快照 (5档)"""
    bid_prices: List[float] = field(default_factory=list)
    bid_volumes: List[int] = field(default_factory=list)
    ask_prices: List[float] = field(default_factory=list)
    ask_volumes: List[int] = field(default_factory=list)
    timestamp_ms: int = 0

@dataclass
class SignalContext:
    """信号上下文"""
    # 特征
    feature_values: Dict[str, float] = field(default_factory=dict)

    # H1e特有
    imb_value: float = 0.0
    depth_value: int = 0
    volatility: float = 0.0

    # LSTM特有
    prediction_prob: float = 0.5
    rsi_value: float = 50.0

    # 信号
    signal_direction: int = 0  # 1=多, -1=空, 0=无
    signal_strength: str = ""  # weak/medium/strong

@dataclass
class ExecutionContext:
    """执行上下文"""
    # 订单信息
    order_ref: str = ""
    order_sys_id: str = ""
    order_price: float = 0.0
    order_volume: int = 0

    # 成交信息
    fill_price: float = 0.0
    fill_volume: int = 0

    # 滑点分析
    slippage_ticks: float = 0.0
    slippage_pct: float = 0.0

    # 延迟统计
    signal_to_order_ms: int = 0
    order_to_fill_ms: int = 0
    total_latency_ms: int = 0

@dataclass
class TradeContext:
    """
    完整交易上下文
    来源: C:\Repo\future-trading-strategy\live\trade_context.py

    用途:
    - 记录交易全链路数据
    - 支持事后复盘验证
    - 异步保存不影响交易
    """

    # 基本信息
    trade_id: str = ""
    symbol: str = ""
    strategy_name: str = ""
    trade_type: str = ""  # "entry" or "exit"
    timestamp: str = ""

    # L1/L2快照
    l1_snapshot: Optional[L1Snapshot] = None
    l2_snapshot: Optional[L2Snapshot] = None

    # 信号上下文
    signal: Optional[SignalContext] = None

    # 执行上下文
    execution: Optional[ExecutionContext] = None

    # 原始tick窗口 (可选，用于深度复盘)
    raw_ticks: Optional[List[Dict]] = None

    # 元数据
    model_version: str = ""
    strategy_version: str = ""

    def generate_id(self) -> str:
        """生成唯一ID"""
        content = f"{self.symbol}_{self.timestamp}_{self.trade_type}"
        return hashlib.md5(content.encode()).hexdigest()[:12]

    def to_dict(self) -> Dict[str, Any]:
        """转换为字典"""
        return asdict(self)

    def to_json(self) -> str:
        """转换为JSON字符串"""
        return json.dumps(self.to_dict(), default=str, ensure_ascii=False, indent=2)
```

### 10.9 ContextManager - 异步保存管理器

```python
# ctp_trading_system/data/context_manager.py

import queue
import threading
import pickle
import json
from pathlib import Path
from datetime import datetime
from typing import Optional

from .trade_context import TradeContext

class ContextManager:
    """
    交易上下文异步保存管理器
    来源: C:\Repo\future-trading-strategy\live\trade_context.py

    特点:
    - 异步保存 (非阻塞，不影响交易执行)
    - 后台线程 + 消息队列
    - 双格式存储: Pickle (完整) + JSON (可读)
    """

    def __init__(self, base_dir: str = None):
        if base_dir is None:
            base_dir = Path(__file__).parent.parent / "data_backup"
        self.base_dir = Path(base_dir)
        self.base_dir.mkdir(parents=True, exist_ok=True)

        self._queue: queue.Queue = queue.Queue()
        self._running = False
        self._worker_thread: Optional[threading.Thread] = None

    def start(self):
        """启动后台保存线程"""
        if self._running:
            return

        self._running = True
        self._worker_thread = threading.Thread(target=self._save_worker, daemon=True)
        self._worker_thread.start()

    def stop(self):
        """停止后台线程"""
        self._running = False
        if self._worker_thread:
            self._worker_thread.join(timeout=5)

    def save(self, ctx: TradeContext):
        """
        保存交易上下文 (非阻塞)

        立即返回，实际保存在后台线程执行
        """
        if not ctx.trade_id:
            ctx.trade_id = ctx.generate_id()
        self._queue.put(ctx)

    def _save_worker(self):
        """后台保存线程"""
        while self._running:
            try:
                ctx = self._queue.get(timeout=1)
                self._save_to_disk(ctx)
            except queue.Empty:
                continue
            except Exception as e:
                print(f"[ContextManager] 保存失败: {e}")

    def _save_to_disk(self, ctx: TradeContext):
        """实际保存到磁盘"""
        # 构建路径: base_dir/{symbol}/{date}/
        date_str = datetime.now().strftime("%Y-%m-%d")
        save_dir = self.base_dir / ctx.symbol / date_str
        save_dir.mkdir(parents=True, exist_ok=True)

        base_name = f"ctx_{ctx.trade_id}"

        # 保存Pickle (完整数据)
        pkl_path = save_dir / f"{base_name}.pkl"
        with open(pkl_path, 'wb') as f:
            pickle.dump(ctx, f)

        # 保存JSON (可读摘要)
        json_path = save_dir / f"{base_name}.json"
        with open(json_path, 'w', encoding='utf-8') as f:
            f.write(ctx.to_json())

    def get_daily_contexts(self, symbol: str, date: str) -> list:
        """获取某日所有上下文"""
        save_dir = self.base_dir / symbol / date
        if not save_dir.exists():
            return []

        contexts = []
        for pkl_file in save_dir.glob("ctx_*.pkl"):
            with open(pkl_file, 'rb') as f:
                contexts.append(pickle.load(f))

        return sorted(contexts, key=lambda x: x.timestamp)
```

### 10.10 数据流集成

```python
# 策略中使用示例

class H1eTickStrategy:
    def __init__(self, ...):
        # 初始化数据缓存
        self._tick_cache = TickCache(maxlen=120)
        self._context_manager = ContextManager()
        self._context_manager.start()

    def on_tick(self, tick_data: dict):
        # 1. 添加到缓存
        tick = TickData(**tick_data)
        self._tick_cache.add_tick(tick)

        # 2. 提取特征
        if self._tick_cache.is_ready():
            features = self._tick_cache.extract_features()

        # 3. 信号生成 & 交易执行
        # ...

        # 4. 异步保存上下文 (非阻塞)
        if trade_executed:
            ctx = TradeContext(
                symbol=self.config.instrument_id,
                strategy_name="H1e_TICK",
                trade_type="entry",
                timestamp=datetime.now().isoformat(),
                l1_snapshot=L1Snapshot(...),
                signal=SignalContext(imb_value=features['imb_mean'], ...),
                execution=ExecutionContext(order_ref=order_ref, ...),
                raw_ticks=self._tick_cache.get_ticks() if save_raw else None
            )
            self._context_manager.save(ctx)  # 立即返回
```

### 10.11 存储策略：全量保存

**设计原则**: 存储成本低廉，全部使用Full级别，确保100%可复现。

| 指标 | 数值 |
|------|------|
| 每笔大小 | ~15 KB |
| 每日 (2000笔) | ~30 MB |
| 每月 | ~900 MB |
| 每年 | ~11 GB |
| 10年 | ~110 GB |

**硬盘几个T，内存32G → 完全无压力**

### 10.12 完整快照设计

```python
@dataclass
class TradeContext:
    """每笔交易保存完整快照 - 100%可复现"""

    # ========== 基本信息 ==========
    trade_id: str
    symbol: str
    strategy_name: str          # H1e_TICK / LSTM_L2
    trade_type: str             # entry / exit
    timestamp: str

    # ========== 完整缓存快照 ==========
    # 原始tick窗口 (用于复现IMB计算)
    tick_window: List[TickData]       # 120个tick, ~6KB

    # Bar序列 (用于复现特征计算)
    bar_sequence: List[BarData]       # 10根bar, ~1KB

    # 特征矩阵 (用于复现LSTM推理)
    feature_matrix: np.ndarray        # [10, 68], ~3KB
    feature_matrix_scaled: np.ndarray # 标准化后

    # L2深度 (用于复现冰山单/大单检测)
    l2_depth: L2Snapshot              # 5档盘口, ~0.5KB

    # ========== 信号上下文 ==========
    signal: SignalContext
    # - imb_value (H1e)
    # - prediction_prob (LSTM)
    # - rsi_value
    # - signal_direction

    # ========== 执行上下文 ==========
    execution: ExecutionContext
    # - order_ref, order_sys_id
    # - fill_price, slippage
    # - latency_ms

    # ========== 元数据 ==========
    model_version: str
    strategy_version: str
```

### 10.13 复现能力

保存完整快照后，可以：

| 复现场景 | 所需数据 | 支持 |
|---------|---------|------|
| 复现IMB计算 | tick_window | ✅ |
| 复现特征计算 | bar_sequence | ✅ |
| 复现LSTM推理 | feature_matrix | ✅ |
| 复现信号生成 | signal context | ✅ |
| 分析滑点差异 | execution context | ✅ |
| 验证策略收益 | 全部数据 | ✅ |

**结论**: 全量保存，简单粗暴，100%可复现。

---

## 十一、实现路线图

### Phase 1: 基础框架
- [ ] 创建目录结构 (data/, storage/, risk/)
- [ ] 实现TradeRecord数据模型 (综合两策略字段)
- [ ] 实现SQLite数据库管理
- [ ] 实现StrategyManager基础框架

### Phase 2: 数据缓存与备份
- [ ] 实现TickCache (120 tick滚动窗口)
- [ ] 实现BarAggregator (tick→bar聚合)
- [ ] 实现TradeContext (完整交易上下文)
- [ ] 实现ContextManager (异步非阻塞保存)
- [ ] 创建data_backup目录结构

### Phase 3: H1e Tick策略
- [ ] 移植IMB计算逻辑 (order_flow_imbalance.py)
- [ ] 实现V4利润奔跑出场规则
- [ ] 实现日内风控 (-0.7%日止损)
- [ ] 集成TickCache实时特征
- [ ] 对接CTP实时行情
- [ ] 回测验证收益一致性 (+13,706%)

### Phase 4: LSTM策略
- [ ] 移植LSTM模型加载 (model_cache_tick)
- [ ] 实现93特征工程
- [ ] 实现三态状态机 (Flat→Probe→Full→Trail)
- [ ] 对接CTP分钟Bar
- [ ] 回测验证收益一致性 (+2,618%)

### Phase 5: 集成测试
- [ ] 策略切换测试
- [ ] 同时运行测试
- [ ] 仓位分配测试
- [ ] 交易记录存储测试
- [ ] TradeContext备份验证

### Phase 6: UI扩展
- [ ] 策略选择面板
- [ ] 仓位配置界面
- [ ] 交易记录查询
- [ ] 收益统计图表
- [ ] 数据备份浏览

---

## 十二、关键依赖

### 模型文件 (必须)
```
C:\Repo\future-trading-strategy\experiments\model_cache_tick\
├── 90f7e5a7810b_lstm_model.pt    # LSTM模型权重
└── 90f7e5a7810b_lstm_scaler.pkl  # 特征标准化器
```

### 特征数据 (可选,用于冰山/大单特征)
```
C:\ProcessedData\
├── iceberg_experiment\iceberg_features_all.parquet
├── large_order_experiment\large_order_features_all.parquet
└── volatility_experiment\volatility_features.parquet
```

### Python依赖
```
torch>=1.9.0
numpy>=1.19.0
pandas>=1.3.0
scikit-learn>=0.24.0  # Scaler
```

---

## 十三、风险说明

1. **收益不保证**: 回测收益不代表实盘收益，市场条件变化可能导致策略失效
2. **滑点影响**: 实盘滑点可能高于回测假设，特别是H1e高频策略
3. **网络延迟**: CTP网络延迟可能影响H1e策略的信号时效性
4. **模型泛化**: LSTM模型在新数据上的表现可能不如训练期
5. **仓位管理**: 同时运行多策略时需严格控制总仓位

---

**审核人**: _________________
**审核日期**: _________________
**审核意见**: _________________
